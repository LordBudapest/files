type token =
  | IDENT of (string)
  | CST_CHAR of (string)
  | CST_INT of (string)
  | CST_FLOAT of (string)
  | CST_STRING of (string)
  | CST_WSTRING of (string)
  | NAMED_TYPE of (string)
  | EOF
  | CHAR
  | INT
  | DOUBLE
  | FLOAT
  | VOID
  | INT64
  | INT32
  | ENUM
  | STRUCT
  | TYPEDEF
  | UNION
  | SIGNED
  | UNSIGNED
  | LONG
  | SHORT
  | INT128
  | VOLATILE
  | EXTERN
  | STATIC
  | CONST
  | RESTRICT
  | AUTO
  | REGISTER
  | ARG_e of (string)
  | ARG_eo of (string)
  | ARG_E of (string)
  | ARG_u of (string)
  | ARG_b of (string)
  | ARG_t of (string)
  | ARG_d of (string)
  | ARG_lo of (string)
  | ARG_l of (string)
  | ARG_i of (string)
  | ARG_o of (string)
  | ARG_va of (string)
  | ARG_f of (string)
  | ARG_F of (string)
  | ARG_A of (string)
  | ARG_v of (string)
  | ARG_k of (string)
  | ARG_c of (string)
  | ARG_s of (string)
  | ARG_p of (string)
  | ARG_P of (string)
  | ARG_I of (string)
  | ARG_S of (string)
  | ARG_g of (string)
  | SIZEOF
  | ALIGNOF
  | EQ
  | ARROW
  | DOT
  | EQ_EQ
  | EXCLAM_EQ
  | INF
  | SUP
  | INF_EQ
  | SUP_EQ
  | MINUS_EQ
  | PLUS_EQ
  | STAR_EQ
  | PLUS
  | MINUS
  | STAR
  | SLASH
  | PERCENT
  | TILDE
  | AND
  | PIPE
  | CIRC
  | EXCLAM
  | AND_AND
  | PIPE_PIPE
  | INF_INF
  | SUP_SUP
  | PLUS_PLUS
  | MINUS_MINUS
  | RPAREN
  | LPAREN
  | RBRACE
  | LBRACE
  | LBRACKET
  | RBRACKET
  | COLON
  | SEMICOLON
  | COMMA
  | ELLIPSIS
  | QUEST
  | BREAK
  | CONTINUE
  | GOTO
  | RETURN
  | SWITCH
  | CASE
  | DEFAULT
  | WHILE
  | DO
  | FOR
  | IF
  | THEN
  | ELSE
  | SLASH_EQ
  | PERCENT_EQ
  | AND_EQ
  | PIPE_EQ
  | CIRC_EQ
  | INF_INF_EQ
  | SUP_SUP_EQ
  | ATTRIBUTE
  | INLINE
  | ASM
  | TYPEOF
  | FUNCTION__
  | PRETTY_FUNCTION__
  | LABEL__
  | BUILTIN_VA_ARG
  | BUILTIN_VA_LIST
  | BLOCKATTRIBUTE
  | DECLSPEC
  | PRAGMA

open Parsing;;
let _ = parse_error;;
# 40 "src/formatparse.mly"
open Cil
module E = Errormsg

let parse_error msg : 'a =           (* sm: c++-mode highlight hack: -> ' <- *)
  E.hadErrors := true;
  E.parse_error
    msg


let getArg (argname: string) (args: (string * formatArg) list) =
  try
    snd (List.find (fun (n, a) -> n = argname) args)
  with _ ->
    E.s (error "Pattern string %s does not have argument with name %s"
           !Lexerhack.currentPattern argname)

let wrongArgType (which: string) (expected: string) (found: formatArg) =
  E.s (bug "Expecting %s argument (%s) and found %a\n"
         expected which d_formatarg found)

let doUnop (uo: unop) subexp =
  ((fun args ->
        let e = (fst subexp) args in
        UnOp(uo, e, typeOf e)),

   (fun e -> match e with
     UnOp(uo', e', _) when uo  = uo' -> (snd subexp) e'
   | _ -> None))

let buildPlus e1 e2 : exp =
  let t1 = typeOf e1 in
  if isPointerType t1 then
    BinOp(PlusPI, e1, e2, t1)
  else
    BinOp(PlusA, e1, e2, t1)

let buildMinus e1 e2 : exp =
  let t1 = typeOf e1 in
  let t2 = typeOf e2 in
  if isPointerType t1 then
    if isPointerType t2 then
      BinOp(MinusPP, e1, e2, intType)
    else
      BinOp(MinusPI, e1, e2, t1)
  else
    BinOp(MinusA, e1, e2, t1)

let doBinop bop e1t e2t =
  ((fun args ->
    let e1 = (fst e1t) args in
    let e2 = (fst e2t) args in
    let t1 = typeOf e1 in
    BinOp(bop, e1, e2, t1)),

   (fun e -> match e with
     BinOp(bop', e1, e2, _) when bop' = bop -> begin
       match (snd e1t) e1, (snd e2t) e2 with
         Some m1, Some m2 -> Some (m1 @ m2)
       | _, _ -> None
     end
   | _ -> None))

(* Check the equivalence of two format lists *)
let rec checkSameFormat (fl1: formatArg list) (fl2: formatArg list) =
  match fl1, fl2 with
    [], [] -> true
  | h1::t1, h2::t2 -> begin
      let rec checkOffsetEq o1 o2 =
        match o1, o2 with
          NoOffset, NoOffset -> true
        | Field(f1, o1'), Field(f2, o2') ->
            f1.fname = f2.fname && checkOffsetEq o1' o2'
        | Index(e1, o1'), Index(e2, o2') ->
            checkOffsetEq o1' o2' && checkExpEq e1 e2
        | _, _ -> false

      and checkExpEq e1 e2 =
        match e1, e2 with
          Const(CInt(n1, _, _)), Const(CInt(n2, _, _)) -> n1 = n2
        | Lval l1, Lval l2 -> checkLvalEq l1 l2
        | UnOp(uo1, e1, _), UnOp(uo2, e2, _) ->
            uo1 = uo2 && checkExpEq e1 e2
        | BinOp(bo1, e11, e12, _), BinOp(bo2, e21, e22, _) ->
            bo1 = bo2 && checkExpEq e11 e21 && checkExpEq e21 e22
        | AddrOf l1, AddrOf l2 -> checkLvalEq l1 l2
        | StartOf l1, StartOf l2 -> checkLvalEq l1 l2
        | SizeOf t1, SizeOf t2 -> typeSig t1 = typeSig t2
        | _, _ ->
            ignore (E.warn "checkSameFormat for Fe"); false

      and checkLvalEq l1 l2 =
        match l1, l2 with
          (Var v1, o1), (Var v2, o2) -> v1 == v2 && checkOffsetEq o1 o2
        | (Mem e1, o1), (Mem e2, o2) ->
            checkOffsetEq o1 o2 && checkExpEq e1 e2
        | _, _ -> false
      in
      let hdeq =
        match h1, h2 with
          Fv v1, Fv v2 -> v1 == v2
        | Fd n1, Fd n2 -> n1 = n2
        | Fe e1, Fe e2 -> checkExpEq e1 e2
        | Fi i1, Fi i2 -> ignore (E.warn "checkSameFormat for Fi"); false
        | Ft t1, Ft t2 -> typeSig t1 = typeSig t2
        | Fl l1, Fl l2 -> checkLvalEq l1 l2
        | Fo o1, Fo o2 -> checkOffsetEq o1 o2
        | Fc c1, Fc c2 -> c1 == c2
        | _, _ -> false
      in
      hdeq || checkSameFormat t1 t2
  end
  | _, _ -> false

let matchBinopEq (bopeq: binop -> bool) lvt et =
  (fun i -> match i with
    Set (lv, BinOp(bop', Lval (lv'), e', _), l, el) when bopeq bop' -> begin
      match lvt lv, lvt lv', et e' with
        Some m1, Some m1', Some m2 ->
          (* Must check that m1 and m2 are the same *)
          if checkSameFormat m1 m1' then
            Some (m1 @ m2)
          else
            None
      | _, _, _ -> None
     end
  | _ -> None)

let doBinopEq bop lvt et =
  ((fun loc args ->
    let l = (fst lvt) args in
    Set(l, BinOp(bop, (Lval l), (fst et) args, typeOfLval l), loc, locUnknown)), (* TODO: better eloc? *)

   matchBinopEq (fun bop' -> bop = bop') (snd lvt) (snd et))


let getField (bt: typ) (fname: string) : fieldinfo =
  match unrollType bt with
    TComp(ci, _) -> begin
      try
        List.find (fun f -> fname = f.fname) ci.cfields
      with Not_found ->
        E.s (bug "Cannot find field %s in %s\n" fname (compFullName ci))
    end
  | t -> E.s (bug "Trying to access field %s in non-struct\n" fname)


let matchIntType (ik: ikind) (t:typ) : formatArg list option =
  match unrollType t with
    TInt(ik', _) when ik = ik' -> Some []
  | _ -> None

let matchFloatType (fk: fkind) (t:typ) : formatArg list option =
  match unrollType t with
    TFloat(fk', _) when fk = fk' -> Some []
  | _ -> None

let doAttr (id: string)
           (aargs: (((string * formatArg) list -> attrparam list) *
                    (attrparam list -> formatArg list option)) option)
    =
  let t = match aargs with
    Some t -> t
  | None -> (fun _ -> []),
            (function [] -> Some [] | _ -> None)
  in
  ((fun args -> Attr (id, (fst t) args)),

   (fun attrs ->
     (* Find the attributes with the same ID *)
     List.fold_left
       (fun acc a ->
         match acc, a with
           Some _, _ -> acc (* We found one already *)
         | None, Attr(id', args) when id = id' ->
             (* Now match the arguments *)
             (snd t) args
         | None, _ -> acc)
       None
       attrs))


type maybeInit =
    NoInit
  | InitExp of exp
  | InitCall of lval * exp list

# 321 "src/formatparse.ml"
let yytransl_const = [|
    0 (* EOF *);
  264 (* CHAR *);
  265 (* INT *);
  266 (* DOUBLE *);
  267 (* FLOAT *);
  268 (* VOID *);
  269 (* INT64 *);
  270 (* INT32 *);
  271 (* ENUM *);
  272 (* STRUCT *);
  273 (* TYPEDEF *);
  274 (* UNION *);
  275 (* SIGNED *);
  276 (* UNSIGNED *);
  277 (* LONG *);
  278 (* SHORT *);
  279 (* INT128 *);
  280 (* VOLATILE *);
  281 (* EXTERN *);
  282 (* STATIC *);
  283 (* CONST *);
  284 (* RESTRICT *);
  285 (* AUTO *);
  286 (* REGISTER *);
  311 (* SIZEOF *);
  312 (* ALIGNOF *);
  313 (* EQ *);
  314 (* ARROW *);
  315 (* DOT *);
  316 (* EQ_EQ *);
  317 (* EXCLAM_EQ *);
  318 (* INF *);
  319 (* SUP *);
  320 (* INF_EQ *);
  321 (* SUP_EQ *);
  322 (* MINUS_EQ *);
  323 (* PLUS_EQ *);
  324 (* STAR_EQ *);
  325 (* PLUS *);
  326 (* MINUS *);
  327 (* STAR *);
  328 (* SLASH *);
  329 (* PERCENT *);
  330 (* TILDE *);
  331 (* AND *);
  332 (* PIPE *);
  333 (* CIRC *);
  334 (* EXCLAM *);
  335 (* AND_AND *);
  336 (* PIPE_PIPE *);
  337 (* INF_INF *);
  338 (* SUP_SUP *);
  339 (* PLUS_PLUS *);
  340 (* MINUS_MINUS *);
  341 (* RPAREN *);
  342 (* LPAREN *);
  343 (* RBRACE *);
  344 (* LBRACE *);
  345 (* LBRACKET *);
  346 (* RBRACKET *);
  347 (* COLON *);
  348 (* SEMICOLON *);
  349 (* COMMA *);
  350 (* ELLIPSIS *);
  351 (* QUEST *);
  352 (* BREAK *);
  353 (* CONTINUE *);
  354 (* GOTO *);
  355 (* RETURN *);
  356 (* SWITCH *);
  357 (* CASE *);
  358 (* DEFAULT *);
  359 (* WHILE *);
  360 (* DO *);
  361 (* FOR *);
  362 (* IF *);
  363 (* THEN *);
  364 (* ELSE *);
  365 (* SLASH_EQ *);
  366 (* PERCENT_EQ *);
  367 (* AND_EQ *);
  368 (* PIPE_EQ *);
  369 (* CIRC_EQ *);
  370 (* INF_INF_EQ *);
  371 (* SUP_SUP_EQ *);
  372 (* ATTRIBUTE *);
  373 (* INLINE *);
  374 (* ASM *);
  375 (* TYPEOF *);
  376 (* FUNCTION__ *);
  377 (* PRETTY_FUNCTION__ *);
  378 (* LABEL__ *);
  379 (* BUILTIN_VA_ARG *);
  380 (* BUILTIN_VA_LIST *);
  381 (* BLOCKATTRIBUTE *);
  382 (* DECLSPEC *);
  383 (* PRAGMA *);
    0|]

let yytransl_block = [|
  257 (* IDENT *);
  258 (* CST_CHAR *);
  259 (* CST_INT *);
  260 (* CST_FLOAT *);
  261 (* CST_STRING *);
  262 (* CST_WSTRING *);
  263 (* NAMED_TYPE *);
  287 (* ARG_e *);
  288 (* ARG_eo *);
  289 (* ARG_E *);
  290 (* ARG_u *);
  291 (* ARG_b *);
  292 (* ARG_t *);
  293 (* ARG_d *);
  294 (* ARG_lo *);
  295 (* ARG_l *);
  296 (* ARG_i *);
  297 (* ARG_o *);
  298 (* ARG_va *);
  299 (* ARG_f *);
  300 (* ARG_F *);
  301 (* ARG_A *);
  302 (* ARG_v *);
  303 (* ARG_k *);
  304 (* ARG_c *);
  305 (* ARG_s *);
  306 (* ARG_p *);
  307 (* ARG_P *);
  308 (* ARG_I *);
  309 (* ARG_S *);
  310 (* ARG_g *);
    0|]

let yylhs = "\255\255\
\001\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000\
\002\000\012\000\013\000\009\000\009\000\009\000\005\000\005\000\
\005\000\005\000\005\000\014\000\014\000\004\000\004\000\004\000\
\004\000\003\000\015\000\015\000\010\000\010\000\010\000\010\000\
\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
\010\000\010\000\010\000\010\000\010\000\010\000\010\000\010\000\
\017\000\017\000\018\000\018\000\018\000\018\000\018\000\011\000\
\011\000\020\000\020\000\020\000\020\000\020\000\019\000\019\000\
\019\000\016\000\016\000\016\000\021\000\021\000\021\000\021\000\
\022\000\022\000\023\000\023\000\023\000\024\000\024\000\024\000\
\006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
\006\000\006\000\006\000\006\000\006\000\006\000\006\000\026\000\
\025\000\025\000\027\000\027\000\027\000\007\000\007\000\007\000\
\007\000\007\000\007\000\007\000\007\000\007\000\008\000\008\000\
\008\000\008\000\028\000\028\000\028\000\029\000\029\000\029\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

let yylen = "\002\000\
\000\000\001\000\001\000\001\000\002\000\004\000\002\000\004\000\
\002\000\002\000\002\000\002\000\002\000\002\000\003\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
\004\000\001\000\001\000\001\000\001\000\001\000\001\000\002\000\
\002\000\004\000\005\000\001\000\001\000\001\000\000\000\003\000\
\004\000\001\000\003\000\001\000\001\000\001\000\001\000\001\000\
\002\000\001\000\002\000\001\000\002\000\001\000\002\000\002\000\
\003\000\001\000\002\000\001\000\001\000\002\000\002\000\004\000\
\003\000\001\000\000\000\001\000\004\000\004\000\007\000\000\000\
\001\000\001\000\001\000\001\000\001\000\003\000\000\000\001\000\
\001\000\000\000\001\000\002\000\001\000\001\000\001\000\006\000\
\001\000\004\000\001\000\003\000\001\000\001\000\004\000\001\000\
\002\000\004\000\004\000\004\000\004\000\004\000\004\000\004\000\
\004\000\004\000\004\000\004\000\007\000\005\000\006\000\001\000\
\000\000\001\000\001\000\001\000\003\000\005\000\007\000\003\000\
\002\000\002\000\003\000\005\000\001\000\001\000\000\000\001\000\
\002\000\006\000\001\000\001\000\002\000\000\000\002\000\005\000\
\002\000\002\000\002\000\002\000\002\000\002\000\002\000\002\000"

let yydefred = "\000\000\
\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\145\000\045\000\038\000\002\000\034\000\036\000\039\000\
\044\000\037\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\004\000\003\000\000\000\000\000\
\056\000\060\000\069\000\068\000\054\000\000\000\000\000\000\000\
\000\000\058\000\066\000\053\000\052\000\055\000\000\000\147\000\
\000\000\050\000\046\000\000\000\000\000\148\000\000\000\000\000\
\120\000\000\000\000\000\150\000\000\000\134\000\140\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\151\000\133\000\
\136\000\000\000\152\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\035\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\040\000\070\000\071\000\
\057\000\061\000\000\000\059\000\067\000\064\000\000\000\095\000\
\093\000\094\000\091\000\000\000\000\000\000\000\000\000\000\000\
\105\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\129\000\
\130\000\089\000\000\000\000\000\000\000\000\000\141\000\137\000\
\000\000\000\000\000\000\000\000\015\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\065\000\000\000\000\000\076\000\000\000\000\000\051\000\000\000\
\092\000\048\000\000\000\000\000\000\000\000\000\000\000\000\000\
\124\000\000\000\000\000\122\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\131\000\128\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\042\000\072\000\000\000\
\000\000\000\000\000\000\049\000\106\000\000\000\108\000\107\000\
\109\000\000\000\000\000\110\000\111\000\112\000\113\000\114\000\
\115\000\116\000\000\000\000\000\000\000\000\000\000\000\043\000\
\000\000\000\000\073\000\000\000\000\000\000\000\125\000\118\000\
\000\000\132\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\078\000\000\000\119\000\000\000\000\000\138\000\000\000\
\104\000\101\000\000\000\000\000\096\000\000\000\117\000\127\000\
\000\000\000\000\098\000\000\000\083\000\084\000\082\000\000\000\
\000\000\081\000\144\000\000\000\100\000\079\000\000\000\103\000\
\086\000"

let yydgoto = "\009\000\
\010\000\055\000\048\000\054\000\029\000\070\000\074\000\075\000\
\030\000\049\000\024\001\031\000\108\000\032\000\050\000\125\000\
\183\000\184\000\148\000\026\001\126\000\242\000\011\001\012\001\
\195\000\061\000\196\000\072\000\239\000"

let yysindex = "\057\001\
\000\000\160\009\143\255\244\254\160\009\024\009\204\008\073\008\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\202\009\244\009\160\009\160\009\160\009\160\009\
\160\009\160\009\177\008\054\012\000\000\000\000\160\009\244\254\
\000\000\000\000\000\000\000\000\000\000\229\254\234\254\135\255\
\009\255\000\000\000\000\000\000\000\000\000\000\225\254\000\000\
\239\254\000\000\000\000\049\255\160\009\000\000\054\012\000\000\
\000\000\228\254\177\006\000\000\160\009\000\000\000\000\073\008\
\245\254\247\254\072\009\231\254\254\254\166\255\000\000\000\000\
\000\000\073\008\000\000\239\254\177\008\027\255\177\008\027\255\
\017\255\017\255\027\255\027\255\027\255\027\255\160\009\186\011\
\001\255\000\000\090\255\160\009\160\009\160\009\160\009\160\009\
\160\009\160\009\160\009\160\009\160\009\160\009\160\009\160\009\
\160\009\160\009\160\009\160\009\027\255\000\000\000\000\000\000\
\000\000\000\000\074\255\000\000\000\000\000\000\160\009\000\000\
\000\000\000\000\000\000\018\255\011\255\239\254\244\254\155\011\
\000\000\160\009\160\009\160\009\160\009\118\009\160\009\160\009\
\160\009\160\009\160\009\160\009\160\009\020\255\022\255\000\000\
\000\000\000\000\054\012\021\255\160\009\160\009\000\000\000\000\
\011\255\013\255\029\255\220\254\000\000\160\009\244\254\019\009\
\019\009\057\255\057\255\057\255\057\255\017\255\017\255\027\255\
\027\255\027\255\160\012\152\007\135\012\077\255\077\255\110\012\
\000\000\217\011\032\255\000\000\239\254\239\254\000\000\014\255\
\000\000\000\000\244\254\015\010\033\255\048\010\081\010\114\010\
\000\000\126\007\036\255\000\000\147\010\180\010\213\010\246\010\
\023\011\056\011\089\011\118\009\000\000\000\000\248\011\023\012\
\065\255\177\255\177\255\244\254\027\255\000\000\000\000\122\255\
\011\255\011\255\072\009\000\000\000\000\118\009\000\000\000\000\
\000\000\118\009\039\255\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\048\255\204\008\204\008\160\009\042\255\000\000\
\038\255\052\255\000\000\055\255\051\255\083\255\000\000\000\000\
\078\255\000\000\063\255\054\012\076\255\073\008\012\255\087\255\
\088\255\000\000\081\255\000\000\204\008\118\009\000\000\089\255\
\000\000\000\000\092\255\091\255\000\000\023\255\000\000\000\000\
\096\255\012\255\000\000\012\255\000\000\000\000\000\000\098\255\
\095\255\000\000\000\000\104\255\000\000\000\000\023\255\000\000\
\000\000"

let yyrindex = "\000\000\
\000\000\000\000\000\000\191\000\000\000\000\000\000\000\192\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\193\000\000\000\000\000\000\000\187\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\125\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\223\004\000\000\000\000\000\000\000\000\000\000\000\000\087\007\
\000\000\000\000\085\012\000\000\000\000\000\000\000\000\108\255\
\000\000\000\000\106\255\000\000\000\000\101\000\000\000\000\000\
\000\000\003\000\000\000\016\255\000\000\246\000\000\000\049\001\
\245\003\048\004\108\001\167\001\226\001\029\002\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\088\002\000\000\000\000\000\000\
\000\000\000\000\145\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\042\000\094\000\187\000\000\000\
\000\000\000\000\000\000\000\000\000\000\111\255\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\085\012\000\000\000\000\
\000\000\000\000\204\254\000\000\000\000\000\000\000\000\000\000\
\224\254\000\000\000\000\242\007\000\000\000\000\187\000\067\006\
\126\006\087\005\146\005\205\005\008\006\107\004\166\004\147\002\
\206\002\009\003\185\006\028\007\244\006\225\004\028\005\048\000\
\000\000\000\000\000\000\000\000\094\000\007\255\000\000\009\000\
\000\000\000\000\187\000\000\000\122\011\000\000\000\000\000\000\
\000\000\114\255\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\111\255\000\000\000\000\000\000\000\000\
\109\255\068\003\127\003\187\000\186\003\000\000\000\000\000\000\
\136\000\194\254\112\255\000\000\000\000\111\255\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\124\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\001\000\115\255\122\011\003\000\000\000\000\000\
\182\000\000\000\000\000\000\000\000\000\111\255\000\000\187\254\
\000\000\000\000\000\000\125\255\000\000\128\255\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\130\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000"

let yygindex = "\000\000\
\000\000\151\008\248\255\229\255\046\000\211\000\249\255\196\255\
\000\000\250\255\000\000\000\000\000\000\000\000\006\255\186\255\
\118\255\000\000\005\000\188\255\000\000\000\000\054\255\000\000\
\070\255\000\000\255\255\156\000\000\000"

let yytablesize = 3570
let yytable = "\071\000\
\126\000\076\000\135\000\143\000\110\000\153\000\120\000\090\000\
\074\000\121\000\122\000\180\000\008\001\152\000\209\000\102\000\
\090\000\235\000\089\000\025\001\111\000\091\000\075\000\102\000\
\075\000\112\000\075\000\123\000\051\000\118\000\033\000\034\000\
\035\000\036\000\037\000\246\000\025\001\088\000\038\000\088\000\
\039\000\075\000\040\000\041\000\042\000\043\000\052\000\018\000\
\212\000\127\000\056\000\059\000\059\000\059\000\119\000\185\000\
\075\000\076\000\044\000\075\000\149\000\009\001\010\001\129\000\
\021\001\045\000\022\001\076\000\154\000\046\000\155\000\028\001\
\090\000\029\001\091\000\017\001\053\000\090\000\243\000\244\000\
\144\000\181\000\145\000\150\000\091\000\158\000\090\000\100\000\
\101\000\102\000\159\000\090\000\090\000\090\000\177\000\090\000\
\182\000\210\000\124\000\186\000\139\000\090\000\219\000\179\000\
\090\000\204\000\142\000\090\000\205\000\059\000\217\000\218\000\
\206\000\211\000\091\000\059\000\023\001\216\000\222\000\059\000\
\227\000\238\000\241\000\255\000\062\000\098\000\099\000\100\000\
\101\000\102\000\248\000\214\000\249\000\254\000\091\000\075\000\
\000\001\106\000\107\000\001\001\002\001\047\000\113\000\114\000\
\063\000\098\000\099\000\100\000\101\000\102\000\033\000\034\000\
\035\000\036\000\037\000\115\000\116\000\117\000\038\000\220\000\
\039\000\006\001\040\000\041\000\042\000\043\000\011\000\003\001\
\012\000\004\001\005\001\013\001\015\001\014\001\018\001\189\000\
\019\001\011\000\044\000\012\000\027\001\077\000\030\001\020\001\
\240\000\045\000\047\000\031\001\032\001\046\000\047\000\135\000\
\146\000\007\001\135\000\121\000\013\000\087\000\123\000\014\000\
\142\000\087\000\015\000\057\000\016\000\058\000\143\000\013\000\
\097\000\099\000\014\000\017\000\080\000\015\000\085\000\016\000\
\060\000\063\000\033\001\018\000\019\000\020\000\017\000\245\000\
\247\000\151\000\000\000\000\000\250\000\251\000\018\000\019\000\
\020\000\000\000\021\000\022\000\023\000\000\000\000\000\024\000\
\025\000\000\000\000\000\026\000\000\000\005\000\000\000\076\000\
\000\000\000\000\024\000\027\000\000\000\016\001\026\000\000\000\
\000\000\126\000\000\000\126\000\000\000\047\000\027\000\000\000\
\126\000\126\000\126\000\126\000\126\000\000\000\000\000\000\000\
\126\000\000\000\126\000\000\000\126\000\126\000\126\000\126\000\
\000\000\059\000\059\000\253\000\000\000\000\000\000\000\126\000\
\000\000\000\000\126\000\000\000\126\000\126\000\126\000\126\000\
\126\000\000\000\000\000\059\000\000\000\000\000\126\000\126\000\
\007\000\126\000\059\000\000\000\126\000\126\000\126\000\126\000\
\126\000\001\000\002\000\003\000\004\000\005\000\006\000\007\000\
\008\000\074\000\000\000\000\000\000\000\126\000\126\000\126\000\
\000\000\000\000\126\000\126\000\000\000\000\000\126\000\000\000\
\000\000\000\000\018\000\000\000\000\000\000\000\126\000\126\000\
\126\000\135\000\000\000\000\000\000\000\074\000\090\000\000\000\
\126\000\126\000\000\000\126\000\074\000\074\000\000\000\126\000\
\018\000\000\000\126\000\041\000\139\000\139\000\139\000\139\000\
\139\000\018\000\018\000\018\000\139\000\000\000\139\000\126\000\
\139\000\139\000\139\000\139\000\000\000\062\000\075\000\000\000\
\000\000\000\000\075\000\000\000\018\000\018\000\075\000\000\000\
\139\000\018\000\000\000\018\000\018\000\000\000\000\000\000\000\
\000\000\063\000\000\000\139\000\062\000\139\000\090\000\062\000\
\062\000\139\000\000\000\000\000\018\000\018\000\018\000\018\000\
\018\000\018\000\018\000\000\000\090\000\000\000\012\000\000\000\
\063\000\062\000\000\000\063\000\063\000\000\000\000\000\000\000\
\000\000\000\000\090\000\090\000\000\000\062\000\090\000\000\000\
\000\000\090\000\090\000\139\000\139\000\063\000\000\000\000\000\
\075\000\000\000\000\000\062\000\139\000\139\000\000\000\139\000\
\000\000\063\000\000\000\139\000\000\000\000\000\139\000\000\000\
\139\000\062\000\062\000\000\000\000\000\062\000\000\000\063\000\
\062\000\062\000\000\000\139\000\075\000\047\000\000\000\000\000\
\075\000\014\000\000\000\075\000\075\000\063\000\063\000\000\000\
\000\000\063\000\000\000\000\000\063\000\063\000\077\000\000\000\
\062\000\000\000\000\000\047\000\047\000\000\000\047\000\047\000\
\047\000\047\000\047\000\047\000\047\000\047\000\047\000\047\000\
\047\000\047\000\047\000\047\000\063\000\047\000\047\000\047\000\
\000\000\000\000\077\000\047\000\047\000\000\000\077\000\047\000\
\047\000\077\000\077\000\000\000\047\000\000\000\047\000\047\000\
\005\000\000\000\000\000\000\000\011\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\047\000\
\047\000\047\000\047\000\047\000\047\000\047\000\005\000\000\000\
\000\000\005\000\005\000\005\000\005\000\005\000\005\000\005\000\
\005\000\005\000\005\000\005\000\005\000\005\000\005\000\000\000\
\005\000\005\000\005\000\000\000\000\000\000\000\005\000\005\000\
\000\000\000\000\005\000\005\000\000\000\000\000\000\000\005\000\
\000\000\005\000\005\000\007\000\000\000\000\000\000\000\013\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\005\000\005\000\005\000\005\000\005\000\005\000\
\005\000\007\000\000\000\000\000\007\000\007\000\007\000\007\000\
\007\000\007\000\007\000\007\000\007\000\007\000\007\000\007\000\
\007\000\007\000\000\000\007\000\007\000\007\000\000\000\000\000\
\000\000\007\000\007\000\000\000\000\000\007\000\007\000\000\000\
\000\000\000\000\007\000\000\000\007\000\007\000\041\000\000\000\
\000\000\000\000\019\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\007\000\007\000\007\000\
\007\000\007\000\007\000\007\000\041\000\000\000\000\000\041\000\
\041\000\041\000\041\000\041\000\041\000\041\000\041\000\041\000\
\041\000\041\000\041\000\041\000\041\000\000\000\041\000\041\000\
\041\000\000\000\000\000\000\000\041\000\041\000\000\000\000\000\
\041\000\041\000\000\000\000\000\000\000\041\000\000\000\041\000\
\041\000\012\000\000\000\000\000\000\000\020\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\041\000\041\000\041\000\041\000\041\000\041\000\041\000\012\000\
\000\000\000\000\012\000\012\000\012\000\012\000\012\000\012\000\
\012\000\012\000\012\000\012\000\012\000\012\000\012\000\012\000\
\000\000\012\000\012\000\012\000\000\000\000\000\000\000\012\000\
\012\000\000\000\000\000\012\000\012\000\000\000\000\000\000\000\
\012\000\000\000\012\000\012\000\014\000\000\000\000\000\000\000\
\021\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\012\000\012\000\012\000\012\000\012\000\
\012\000\012\000\014\000\000\000\000\000\014\000\014\000\014\000\
\014\000\014\000\014\000\014\000\014\000\014\000\014\000\014\000\
\014\000\014\000\014\000\000\000\014\000\014\000\014\000\000\000\
\000\000\000\000\014\000\014\000\000\000\000\000\014\000\014\000\
\000\000\000\000\000\000\014\000\000\000\014\000\014\000\011\000\
\000\000\000\000\000\000\006\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\014\000\014\000\
\014\000\014\000\014\000\014\000\014\000\011\000\000\000\000\000\
\011\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
\011\000\011\000\011\000\011\000\011\000\011\000\000\000\011\000\
\011\000\011\000\000\000\000\000\000\000\011\000\011\000\000\000\
\000\000\011\000\011\000\000\000\000\000\000\000\011\000\000\000\
\011\000\011\000\013\000\000\000\000\000\000\000\008\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\011\000\011\000\011\000\011\000\011\000\011\000\011\000\
\013\000\000\000\000\000\013\000\013\000\013\000\013\000\013\000\
\013\000\013\000\013\000\013\000\013\000\013\000\013\000\013\000\
\013\000\000\000\013\000\013\000\013\000\000\000\000\000\000\000\
\013\000\013\000\000\000\000\000\013\000\013\000\000\000\000\000\
\000\000\013\000\000\000\013\000\013\000\019\000\000\000\000\000\
\000\000\033\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\013\000\013\000\013\000\013\000\
\013\000\013\000\013\000\019\000\000\000\000\000\019\000\019\000\
\019\000\019\000\019\000\019\000\019\000\019\000\019\000\019\000\
\019\000\019\000\019\000\019\000\000\000\019\000\019\000\019\000\
\000\000\000\000\000\000\019\000\019\000\000\000\000\000\019\000\
\019\000\000\000\000\000\000\000\019\000\000\000\019\000\019\000\
\020\000\000\000\000\000\000\000\009\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\019\000\
\019\000\019\000\019\000\019\000\019\000\019\000\020\000\000\000\
\000\000\020\000\020\000\020\000\020\000\020\000\020\000\020\000\
\020\000\020\000\020\000\020\000\020\000\020\000\020\000\000\000\
\020\000\020\000\020\000\000\000\000\000\000\000\020\000\020\000\
\000\000\000\000\020\000\020\000\000\000\000\000\000\000\020\000\
\000\000\020\000\020\000\021\000\000\000\000\000\000\000\010\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\020\000\020\000\020\000\020\000\020\000\020\000\
\020\000\021\000\000\000\000\000\021\000\021\000\021\000\021\000\
\021\000\021\000\021\000\021\000\021\000\021\000\021\000\021\000\
\021\000\021\000\000\000\021\000\021\000\021\000\000\000\000\000\
\000\000\021\000\021\000\000\000\000\000\021\000\021\000\000\000\
\000\000\000\000\021\000\000\000\021\000\021\000\006\000\000\000\
\000\000\000\000\016\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\021\000\021\000\021\000\
\021\000\021\000\021\000\021\000\006\000\006\000\000\000\006\000\
\006\000\006\000\006\000\006\000\006\000\006\000\006\000\006\000\
\006\000\006\000\006\000\006\000\006\000\000\000\006\000\006\000\
\006\000\000\000\000\000\000\000\006\000\006\000\000\000\000\000\
\006\000\000\000\000\000\000\000\000\000\006\000\000\000\006\000\
\006\000\008\000\000\000\000\000\000\000\017\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\006\000\006\000\006\000\006\000\006\000\006\000\006\000\008\000\
\008\000\000\000\008\000\008\000\008\000\008\000\008\000\008\000\
\008\000\008\000\008\000\008\000\008\000\008\000\008\000\008\000\
\000\000\008\000\008\000\008\000\000\000\000\000\000\000\008\000\
\008\000\000\000\000\000\008\000\000\000\000\000\000\000\000\000\
\008\000\000\000\008\000\008\000\033\000\000\000\090\000\000\000\
\022\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\008\000\008\000\008\000\008\000\008\000\
\008\000\008\000\033\000\000\000\000\000\033\000\033\000\033\000\
\033\000\033\000\033\000\033\000\033\000\033\000\033\000\033\000\
\033\000\033\000\033\000\000\000\033\000\033\000\033\000\000\000\
\000\000\000\000\033\000\033\000\000\000\000\000\033\000\033\000\
\000\000\000\000\000\000\033\000\000\000\033\000\033\000\009\000\
\000\000\000\000\000\000\023\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\033\000\033\000\
\033\000\033\000\033\000\033\000\033\000\009\000\000\000\000\000\
\009\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
\009\000\009\000\009\000\000\000\000\000\000\000\000\000\009\000\
\009\000\009\000\000\000\000\000\000\000\009\000\009\000\000\000\
\000\000\009\000\009\000\000\000\000\000\000\000\009\000\000\000\
\009\000\009\000\010\000\000\000\000\000\000\000\029\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\009\000\009\000\009\000\009\000\009\000\009\000\009\000\
\010\000\000\000\000\000\010\000\010\000\010\000\010\000\010\000\
\010\000\010\000\010\000\010\000\010\000\010\000\000\000\000\000\
\000\000\000\000\010\000\010\000\010\000\000\000\000\000\000\000\
\010\000\010\000\000\000\000\000\010\000\010\000\000\000\000\000\
\000\000\010\000\000\000\010\000\010\000\016\000\000\000\000\000\
\000\000\030\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\010\000\010\000\010\000\010\000\
\010\000\010\000\010\000\016\000\000\000\000\000\016\000\016\000\
\016\000\016\000\016\000\016\000\016\000\016\000\016\000\016\000\
\016\000\000\000\000\000\000\000\000\000\016\000\016\000\016\000\
\000\000\000\000\000\000\016\000\016\000\000\000\000\000\016\000\
\016\000\000\000\000\000\000\000\016\000\000\000\016\000\016\000\
\017\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\
\016\000\016\000\016\000\016\000\016\000\016\000\017\000\090\000\
\000\000\017\000\017\000\017\000\017\000\017\000\017\000\017\000\
\017\000\017\000\017\000\017\000\000\000\000\000\000\000\000\000\
\017\000\017\000\017\000\000\000\000\000\000\000\017\000\017\000\
\000\000\000\000\017\000\017\000\000\000\000\000\000\000\017\000\
\000\000\017\000\017\000\022\000\000\000\000\000\000\000\032\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\017\000\017\000\017\000\017\000\017\000\017\000\
\017\000\022\000\000\000\000\000\022\000\022\000\022\000\022\000\
\022\000\022\000\022\000\022\000\022\000\090\000\000\000\000\000\
\000\000\000\000\000\000\022\000\022\000\022\000\000\000\000\000\
\000\000\022\000\022\000\090\000\090\000\022\000\022\000\090\000\
\000\000\000\000\022\000\090\000\022\000\022\000\023\000\000\000\
\000\000\000\000\027\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\022\000\022\000\022\000\
\022\000\022\000\022\000\022\000\023\000\000\000\000\000\023\000\
\023\000\023\000\023\000\023\000\023\000\023\000\023\000\023\000\
\000\000\000\000\000\000\000\000\000\000\000\000\023\000\023\000\
\023\000\000\000\000\000\000\000\023\000\023\000\000\000\000\000\
\023\000\023\000\000\000\000\000\000\000\023\000\000\000\023\000\
\023\000\029\000\000\000\000\000\000\000\028\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\023\000\023\000\023\000\023\000\023\000\023\000\023\000\029\000\
\000\000\000\000\029\000\029\000\029\000\029\000\029\000\029\000\
\029\000\029\000\029\000\000\000\000\000\000\000\000\000\000\000\
\000\000\029\000\029\000\029\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\029\000\029\000\000\000\000\000\000\000\
\029\000\000\000\029\000\029\000\030\000\000\000\000\000\000\000\
\024\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\029\000\029\000\029\000\029\000\029\000\
\029\000\029\000\030\000\000\000\000\000\030\000\030\000\030\000\
\030\000\030\000\030\000\030\000\030\000\030\000\000\000\000\000\
\000\000\000\000\000\000\000\000\030\000\030\000\030\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\030\000\030\000\
\000\000\000\000\000\000\030\000\000\000\030\000\030\000\031\000\
\000\000\000\000\000\000\026\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\030\000\030\000\
\030\000\030\000\030\000\030\000\030\000\031\000\000\000\000\000\
\031\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
\031\000\000\000\000\000\000\000\000\000\000\000\000\000\031\000\
\031\000\031\000\000\000\025\000\000\000\000\000\000\000\000\000\
\000\000\031\000\031\000\000\000\000\000\000\000\031\000\000\000\
\031\000\031\000\032\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\031\000\031\000\031\000\031\000\031\000\031\000\031\000\
\032\000\000\000\000\000\032\000\032\000\032\000\032\000\032\000\
\032\000\032\000\032\000\032\000\000\000\000\000\000\000\000\000\
\000\000\000\000\032\000\032\000\032\000\000\000\149\000\000\000\
\000\000\000\000\000\000\000\000\032\000\032\000\000\000\000\000\
\000\000\032\000\000\000\032\000\032\000\027\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\032\000\032\000\032\000\032\000\
\032\000\032\000\032\000\027\000\000\000\000\000\027\000\027\000\
\000\000\000\000\000\000\000\000\027\000\027\000\027\000\000\000\
\000\000\000\000\000\000\000\000\000\000\027\000\027\000\027\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\027\000\
\027\000\000\000\000\000\000\000\027\000\000\000\027\000\027\000\
\028\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\027\000\
\027\000\027\000\027\000\027\000\027\000\027\000\028\000\000\000\
\000\000\028\000\028\000\000\000\000\000\000\000\000\000\028\000\
\028\000\028\000\000\000\000\000\000\000\000\000\000\000\000\000\
\028\000\028\000\028\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\028\000\028\000\000\000\000\000\000\000\028\000\
\000\000\028\000\028\000\024\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\130\000\028\000\028\000\028\000\028\000\028\000\028\000\
\028\000\024\000\131\000\132\000\133\000\000\000\000\000\000\000\
\000\000\000\000\024\000\024\000\024\000\000\000\000\000\000\000\
\000\000\000\000\000\000\024\000\024\000\024\000\134\000\000\000\
\000\000\000\000\000\000\000\000\000\000\024\000\024\000\000\000\
\000\000\000\000\024\000\000\000\024\000\024\000\026\000\000\000\
\000\000\000\000\000\000\000\000\000\000\135\000\136\000\137\000\
\138\000\139\000\140\000\141\000\000\000\024\000\024\000\024\000\
\024\000\024\000\024\000\024\000\026\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\026\000\026\000\026\000\
\000\000\000\000\000\000\000\000\000\000\000\000\025\000\026\000\
\026\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\026\000\026\000\000\000\000\000\000\000\026\000\000\000\026\000\
\026\000\000\000\000\000\000\000\025\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\025\000\025\000\025\000\
\026\000\026\000\026\000\026\000\026\000\026\000\026\000\025\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\025\000\025\000\000\000\000\000\000\000\025\000\000\000\025\000\
\025\000\004\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\025\000\025\000\025\000\025\000\025\000\025\000\025\000\000\000\
\004\000\000\000\004\000\004\000\004\000\004\000\004\000\004\000\
\028\000\000\000\000\000\004\000\004\000\004\000\004\000\004\000\
\090\000\004\000\004\000\004\000\000\000\000\000\000\000\004\000\
\004\000\078\000\080\000\081\000\082\000\083\000\084\000\085\000\
\086\000\088\000\000\000\000\000\000\000\109\000\000\000\091\000\
\000\000\092\000\093\000\094\000\095\000\096\000\097\000\000\000\
\000\000\000\000\098\000\099\000\100\000\101\000\102\000\000\000\
\103\000\104\000\105\000\128\000\000\000\000\000\106\000\107\000\
\000\000\091\000\000\000\092\000\093\000\094\000\095\000\096\000\
\097\000\147\000\226\000\000\000\098\000\099\000\100\000\101\000\
\102\000\000\000\103\000\088\000\105\000\088\000\000\000\000\000\
\106\000\107\000\000\000\000\000\000\000\156\000\000\000\000\000\
\000\000\000\000\160\000\161\000\162\000\163\000\164\000\165\000\
\166\000\167\000\168\000\169\000\170\000\171\000\172\000\173\000\
\174\000\175\000\176\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\178\000\000\000\000\000\
\000\000\000\000\000\000\000\000\041\000\000\000\000\000\000\000\
\188\000\190\000\191\000\192\000\194\000\197\000\198\000\199\000\
\200\000\201\000\202\000\203\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\207\000\208\000\041\000\041\000\041\000\
\041\000\041\000\041\000\000\000\213\000\000\000\041\000\041\000\
\041\000\041\000\041\000\000\000\041\000\041\000\041\000\000\000\
\000\000\000\000\041\000\041\000\000\000\000\000\000\000\000\000\
\000\000\011\000\000\000\012\000\000\000\000\000\000\000\000\000\
\033\000\034\000\035\000\036\000\037\000\000\000\000\000\000\000\
\038\000\000\000\039\000\000\000\040\000\041\000\042\000\043\000\
\000\000\000\000\194\000\000\000\000\000\000\000\000\000\013\000\
\213\000\213\000\014\000\000\000\044\000\015\000\057\000\016\000\
\058\000\147\000\000\000\000\000\194\000\000\000\017\000\046\000\
\194\000\062\000\000\000\000\000\063\000\073\000\018\000\019\000\
\020\000\000\000\000\000\000\000\252\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\021\000\022\000\023\000\
\000\000\000\000\024\000\025\000\000\000\000\000\026\000\000\000\
\000\000\000\000\000\000\000\000\194\000\000\000\027\000\000\000\
\064\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\065\000\066\000\000\000\067\000\000\000\000\000\000\000\068\000\
\000\000\011\000\069\000\012\000\000\000\000\000\000\000\000\000\
\033\000\034\000\035\000\036\000\037\000\000\000\000\000\047\000\
\038\000\000\000\039\000\000\000\040\000\041\000\042\000\043\000\
\000\000\000\000\000\000\000\000\011\000\000\000\012\000\013\000\
\000\000\000\000\014\000\000\000\044\000\015\000\000\000\016\000\
\000\000\000\000\000\000\045\000\000\000\000\000\017\000\046\000\
\000\000\000\000\000\000\000\000\000\000\000\000\018\000\019\000\
\020\000\000\000\013\000\000\000\000\000\014\000\000\000\000\000\
\015\000\057\000\016\000\058\000\000\000\021\000\022\000\087\000\
\000\000\017\000\024\000\025\000\062\000\000\000\026\000\063\000\
\000\000\018\000\019\000\020\000\000\000\000\000\027\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\021\000\022\000\023\000\000\000\000\000\024\000\025\000\000\000\
\011\000\026\000\012\000\000\000\000\000\000\000\000\000\000\000\
\000\000\027\000\000\000\064\000\000\000\000\000\000\000\047\000\
\000\000\000\000\000\000\065\000\066\000\000\000\067\000\000\000\
\000\000\000\000\068\000\000\000\000\000\069\000\013\000\000\000\
\000\000\014\000\000\000\000\000\015\000\057\000\016\000\058\000\
\000\000\000\000\000\000\000\000\000\000\017\000\000\000\000\000\
\011\000\000\000\012\000\000\000\091\000\018\000\019\000\020\000\
\094\000\095\000\096\000\097\000\000\000\000\000\000\000\098\000\
\099\000\100\000\101\000\102\000\021\000\022\000\023\000\000\000\
\000\000\024\000\025\000\106\000\107\000\026\000\013\000\146\000\
\000\000\014\000\000\000\000\000\015\000\027\000\016\000\000\000\
\000\000\000\000\000\000\000\000\000\000\017\000\011\000\000\000\
\012\000\000\000\000\000\000\000\000\000\018\000\019\000\020\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\021\000\022\000\023\000\000\000\
\000\000\024\000\025\000\000\000\013\000\026\000\193\000\014\000\
\000\000\000\000\015\000\000\000\016\000\027\000\000\000\000\000\
\011\000\000\000\012\000\017\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\018\000\019\000\020\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\021\000\022\000\023\000\000\000\013\000\024\000\
\025\000\014\000\000\000\026\000\015\000\000\000\016\000\000\000\
\000\000\000\000\011\000\027\000\012\000\017\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\018\000\019\000\020\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\021\000\022\000\023\000\000\000\
\013\000\024\000\025\000\014\000\000\000\026\000\015\000\000\000\
\016\000\000\000\000\000\000\000\011\000\027\000\012\000\017\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\018\000\
\019\000\020\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\021\000\022\000\
\023\000\000\000\013\000\024\000\025\000\014\000\000\000\026\000\
\015\000\000\000\016\000\000\000\000\000\000\000\000\000\077\000\
\000\000\017\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\018\000\019\000\020\000\000\000\000\000\000\000\000\000\
\000\000\090\000\000\000\000\000\000\000\000\000\000\000\000\000\
\021\000\022\000\023\000\000\000\000\000\024\000\025\000\000\000\
\000\000\026\000\000\000\000\000\000\000\000\000\000\000\000\000\
\091\000\079\000\092\000\093\000\094\000\095\000\096\000\097\000\
\000\000\000\000\090\000\098\000\099\000\100\000\101\000\102\000\
\000\000\103\000\104\000\105\000\000\000\000\000\000\000\106\000\
\107\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\091\000\221\000\092\000\093\000\094\000\095\000\096\000\
\097\000\000\000\000\000\090\000\098\000\099\000\100\000\101\000\
\102\000\000\000\103\000\104\000\105\000\000\000\000\000\000\000\
\106\000\107\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\091\000\223\000\092\000\093\000\094\000\095\000\
\096\000\097\000\000\000\000\000\090\000\098\000\099\000\100\000\
\101\000\102\000\000\000\103\000\104\000\105\000\000\000\000\000\
\000\000\106\000\107\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\091\000\224\000\092\000\093\000\094\000\
\095\000\096\000\097\000\000\000\000\000\090\000\098\000\099\000\
\100\000\101\000\102\000\000\000\103\000\104\000\105\000\000\000\
\000\000\000\000\106\000\107\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\091\000\225\000\092\000\093\000\
\094\000\095\000\096\000\097\000\000\000\000\000\090\000\098\000\
\099\000\100\000\101\000\102\000\000\000\103\000\104\000\105\000\
\000\000\000\000\000\000\106\000\107\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\091\000\228\000\092\000\
\093\000\094\000\095\000\096\000\097\000\000\000\000\000\090\000\
\098\000\099\000\100\000\101\000\102\000\000\000\103\000\104\000\
\105\000\000\000\000\000\000\000\106\000\107\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\091\000\229\000\
\092\000\093\000\094\000\095\000\096\000\097\000\000\000\000\000\
\090\000\098\000\099\000\100\000\101\000\102\000\000\000\103\000\
\104\000\105\000\000\000\000\000\000\000\106\000\107\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\091\000\
\230\000\092\000\093\000\094\000\095\000\096\000\097\000\000\000\
\000\000\090\000\098\000\099\000\100\000\101\000\102\000\000\000\
\103\000\104\000\105\000\000\000\000\000\000\000\106\000\107\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\091\000\231\000\092\000\093\000\094\000\095\000\096\000\097\000\
\000\000\000\000\090\000\098\000\099\000\100\000\101\000\102\000\
\000\000\103\000\104\000\105\000\000\000\000\000\000\000\106\000\
\107\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\091\000\232\000\092\000\093\000\094\000\095\000\096\000\
\097\000\000\000\000\000\090\000\098\000\099\000\100\000\101\000\
\102\000\000\000\103\000\104\000\105\000\000\000\000\000\000\000\
\106\000\107\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\091\000\233\000\092\000\093\000\094\000\095\000\
\096\000\097\000\000\000\000\000\004\000\098\000\099\000\100\000\
\101\000\102\000\000\000\103\000\104\000\105\000\000\000\000\000\
\000\000\106\000\107\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\004\000\234\000\004\000\004\000\004\000\
\004\000\004\000\004\000\000\000\000\000\090\000\004\000\004\000\
\004\000\004\000\004\000\000\000\004\000\004\000\004\000\000\000\
\000\000\000\000\004\000\004\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\091\000\004\000\092\000\093\000\
\094\000\095\000\096\000\097\000\090\000\000\000\000\000\098\000\
\099\000\100\000\101\000\102\000\000\000\103\000\104\000\105\000\
\000\000\000\000\000\000\106\000\107\000\000\000\000\000\000\000\
\000\000\000\000\000\000\091\000\187\000\092\000\093\000\094\000\
\095\000\096\000\097\000\090\000\000\000\000\000\098\000\099\000\
\100\000\101\000\102\000\000\000\103\000\104\000\105\000\000\000\
\000\000\000\000\106\000\107\000\000\000\000\000\157\000\000\000\
\000\000\000\000\091\000\000\000\092\000\093\000\094\000\095\000\
\096\000\097\000\090\000\000\000\000\000\098\000\099\000\100\000\
\101\000\102\000\000\000\103\000\104\000\105\000\000\000\000\000\
\000\000\106\000\107\000\000\000\000\000\215\000\000\000\000\000\
\000\000\091\000\000\000\092\000\093\000\094\000\095\000\096\000\
\097\000\090\000\000\000\000\000\098\000\099\000\100\000\101\000\
\102\000\000\000\103\000\104\000\105\000\000\000\000\000\000\000\
\106\000\107\000\000\000\000\000\236\000\000\000\000\000\000\000\
\091\000\000\000\092\000\093\000\094\000\095\000\096\000\097\000\
\090\000\000\000\000\000\098\000\099\000\100\000\101\000\102\000\
\000\000\103\000\104\000\105\000\000\000\000\000\000\000\106\000\
\107\000\000\000\000\000\237\000\000\000\000\000\000\000\091\000\
\000\000\092\000\093\000\094\000\095\000\096\000\097\000\004\000\
\000\000\000\000\098\000\099\000\100\000\101\000\102\000\000\000\
\103\000\104\000\105\000\000\000\000\000\000\000\106\000\107\000\
\000\000\000\000\000\000\000\000\000\000\000\000\004\000\000\000\
\004\000\004\000\004\000\004\000\004\000\004\000\000\000\000\000\
\000\000\004\000\004\000\004\000\004\000\004\000\000\000\004\000\
\004\000\004\000\000\000\000\000\000\000\004\000\004\000\091\000\
\000\000\092\000\093\000\094\000\095\000\096\000\097\000\000\000\
\000\000\000\000\098\000\099\000\100\000\101\000\102\000\000\000\
\103\000\104\000\105\000\000\000\000\000\000\000\106\000\107\000\
\091\000\000\000\092\000\093\000\094\000\095\000\096\000\097\000\
\000\000\000\000\000\000\098\000\099\000\100\000\101\000\102\000\
\000\000\103\000\000\000\000\000\000\000\000\000\000\000\106\000\
\107\000\091\000\000\000\092\000\093\000\094\000\095\000\096\000\
\097\000\000\000\000\000\000\000\098\000\099\000\100\000\101\000\
\102\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\106\000\107\000"

let yycheck = "\007\000\
\000\000\008\000\000\000\064\000\032\000\076\000\024\001\001\001\
\000\000\027\001\028\001\001\001\001\001\074\000\153\000\085\001\
\001\001\204\000\027\000\014\001\048\001\058\001\085\001\093\001\
\057\001\048\001\089\001\045\001\041\001\021\001\008\001\009\001\
\010\001\011\001\012\001\222\000\031\001\090\001\016\001\092\001\
\018\001\000\000\020\001\021\001\022\001\023\001\059\001\000\000\
\085\001\001\001\005\000\006\000\007\000\008\000\086\001\126\000\
\089\001\064\000\036\001\092\001\086\001\050\001\051\001\092\001\
\042\001\043\001\044\001\074\000\077\000\047\001\079\000\018\001\
\057\001\020\001\058\001\006\001\089\001\071\001\217\000\218\000\
\092\001\071\001\092\001\086\001\058\001\085\001\071\001\071\001\
\072\001\073\001\001\001\085\001\086\001\000\000\021\001\089\001\
\086\001\085\001\116\001\127\000\000\000\086\001\089\001\086\001\
\089\001\086\001\061\000\092\001\087\001\064\000\181\000\182\000\
\092\001\085\001\058\001\070\000\094\001\086\001\086\001\074\000\
\085\001\057\001\001\001\086\001\000\000\069\001\070\001\071\001\
\072\001\073\001\092\001\159\000\085\001\092\001\058\001\000\000\
\085\001\081\001\082\001\085\001\090\001\119\001\008\001\009\001\
\000\000\069\001\070\001\071\001\072\001\073\001\008\001\009\001\
\010\001\011\001\012\001\021\001\022\001\023\001\016\001\187\000\
\018\001\086\001\020\001\021\001\022\001\023\001\001\001\085\001\
\003\001\092\001\108\001\085\001\092\001\086\001\086\001\130\000\
\085\001\001\001\036\001\003\001\085\001\000\000\085\001\093\001\
\212\000\043\001\000\000\093\001\085\001\047\001\000\000\000\000\
\000\000\254\000\087\001\085\001\031\001\092\001\085\001\034\001\
\092\001\090\001\037\001\038\001\039\001\040\001\092\001\031\001\
\085\001\085\001\034\001\046\001\085\001\037\001\085\001\039\001\
\006\000\052\001\031\001\054\001\055\001\056\001\046\001\219\000\
\226\000\070\000\255\255\255\255\236\000\237\000\054\001\055\001\
\056\001\255\255\069\001\070\001\071\001\255\255\255\255\074\001\
\075\001\255\255\255\255\078\001\255\255\000\000\255\255\254\000\
\255\255\255\255\074\001\086\001\255\255\005\001\078\001\255\255\
\255\255\001\001\255\255\003\001\255\255\119\001\086\001\255\255\
\008\001\009\001\010\001\011\001\012\001\255\255\255\255\255\255\
\016\001\255\255\018\001\255\255\020\001\021\001\022\001\023\001\
\255\255\236\000\237\000\238\000\255\255\255\255\255\255\031\001\
\255\255\255\255\034\001\255\255\036\001\037\001\038\001\039\001\
\040\001\255\255\255\255\254\000\255\255\255\255\046\001\047\001\
\000\000\049\001\005\001\255\255\052\001\053\001\054\001\055\001\
\056\001\001\000\002\000\003\000\004\000\005\000\006\000\007\000\
\008\000\057\001\255\255\255\255\255\255\069\001\070\001\071\001\
\255\255\255\255\074\001\075\001\255\255\255\255\078\001\255\255\
\255\255\255\255\035\001\255\255\255\255\255\255\086\001\087\001\
\088\001\087\001\255\255\255\255\255\255\085\001\001\001\255\255\
\096\001\097\001\255\255\099\001\092\001\093\001\255\255\103\001\
\057\001\255\255\106\001\000\000\008\001\009\001\010\001\011\001\
\012\001\066\001\067\001\068\001\016\001\255\255\018\001\119\001\
\020\001\021\001\022\001\023\001\255\255\001\001\085\001\255\255\
\255\255\255\255\089\001\255\255\085\001\086\001\093\001\255\255\
\036\001\090\001\255\255\092\001\093\001\255\255\255\255\255\255\
\255\255\001\001\255\255\047\001\024\001\049\001\057\001\027\001\
\028\001\053\001\255\255\255\255\109\001\110\001\111\001\112\001\
\113\001\114\001\115\001\255\255\071\001\255\255\000\000\255\255\
\024\001\045\001\255\255\027\001\028\001\255\255\255\255\255\255\
\255\255\255\255\085\001\086\001\255\255\057\001\089\001\255\255\
\255\255\092\001\093\001\087\001\088\001\045\001\255\255\255\255\
\057\001\255\255\255\255\071\001\096\001\097\001\255\255\099\001\
\255\255\057\001\255\255\103\001\255\255\255\255\106\001\255\255\
\108\001\085\001\086\001\255\255\255\255\089\001\255\255\071\001\
\092\001\093\001\255\255\119\001\085\001\035\001\255\255\255\255\
\089\001\000\000\255\255\092\001\093\001\085\001\086\001\255\255\
\255\255\089\001\255\255\255\255\092\001\093\001\057\001\255\255\
\116\001\255\255\255\255\057\001\058\001\255\255\060\001\061\001\
\062\001\063\001\064\001\065\001\066\001\067\001\068\001\069\001\
\070\001\071\001\072\001\073\001\116\001\075\001\076\001\077\001\
\255\255\255\255\085\001\081\001\082\001\255\255\089\001\085\001\
\086\001\092\001\093\001\255\255\090\001\255\255\092\001\093\001\
\035\001\255\255\255\255\255\255\000\000\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\109\001\
\110\001\111\001\112\001\113\001\114\001\115\001\057\001\255\255\
\255\255\060\001\061\001\062\001\063\001\064\001\065\001\066\001\
\067\001\068\001\069\001\070\001\071\001\072\001\073\001\255\255\
\075\001\076\001\077\001\255\255\255\255\255\255\081\001\082\001\
\255\255\255\255\085\001\086\001\255\255\255\255\255\255\090\001\
\255\255\092\001\093\001\035\001\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\109\001\110\001\111\001\112\001\113\001\114\001\
\115\001\057\001\255\255\255\255\060\001\061\001\062\001\063\001\
\064\001\065\001\066\001\067\001\068\001\069\001\070\001\071\001\
\072\001\073\001\255\255\075\001\076\001\077\001\255\255\255\255\
\255\255\081\001\082\001\255\255\255\255\085\001\086\001\255\255\
\255\255\255\255\090\001\255\255\092\001\093\001\035\001\255\255\
\255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\109\001\110\001\111\001\
\112\001\113\001\114\001\115\001\057\001\255\255\255\255\060\001\
\061\001\062\001\063\001\064\001\065\001\066\001\067\001\068\001\
\069\001\070\001\071\001\072\001\073\001\255\255\075\001\076\001\
\077\001\255\255\255\255\255\255\081\001\082\001\255\255\255\255\
\085\001\086\001\255\255\255\255\255\255\090\001\255\255\092\001\
\093\001\035\001\255\255\255\255\255\255\000\000\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\109\001\110\001\111\001\112\001\113\001\114\001\115\001\057\001\
\255\255\255\255\060\001\061\001\062\001\063\001\064\001\065\001\
\066\001\067\001\068\001\069\001\070\001\071\001\072\001\073\001\
\255\255\075\001\076\001\077\001\255\255\255\255\255\255\081\001\
\082\001\255\255\255\255\085\001\086\001\255\255\255\255\255\255\
\090\001\255\255\092\001\093\001\035\001\255\255\255\255\255\255\
\000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\109\001\110\001\111\001\112\001\113\001\
\114\001\115\001\057\001\255\255\255\255\060\001\061\001\062\001\
\063\001\064\001\065\001\066\001\067\001\068\001\069\001\070\001\
\071\001\072\001\073\001\255\255\075\001\076\001\077\001\255\255\
\255\255\255\255\081\001\082\001\255\255\255\255\085\001\086\001\
\255\255\255\255\255\255\090\001\255\255\092\001\093\001\035\001\
\255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\109\001\110\001\
\111\001\112\001\113\001\114\001\115\001\057\001\255\255\255\255\
\060\001\061\001\062\001\063\001\064\001\065\001\066\001\067\001\
\068\001\069\001\070\001\071\001\072\001\073\001\255\255\075\001\
\076\001\077\001\255\255\255\255\255\255\081\001\082\001\255\255\
\255\255\085\001\086\001\255\255\255\255\255\255\090\001\255\255\
\092\001\093\001\035\001\255\255\255\255\255\255\000\000\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\109\001\110\001\111\001\112\001\113\001\114\001\115\001\
\057\001\255\255\255\255\060\001\061\001\062\001\063\001\064\001\
\065\001\066\001\067\001\068\001\069\001\070\001\071\001\072\001\
\073\001\255\255\075\001\076\001\077\001\255\255\255\255\255\255\
\081\001\082\001\255\255\255\255\085\001\086\001\255\255\255\255\
\255\255\090\001\255\255\092\001\093\001\035\001\255\255\255\255\
\255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\109\001\110\001\111\001\112\001\
\113\001\114\001\115\001\057\001\255\255\255\255\060\001\061\001\
\062\001\063\001\064\001\065\001\066\001\067\001\068\001\069\001\
\070\001\071\001\072\001\073\001\255\255\075\001\076\001\077\001\
\255\255\255\255\255\255\081\001\082\001\255\255\255\255\085\001\
\086\001\255\255\255\255\255\255\090\001\255\255\092\001\093\001\
\035\001\255\255\255\255\255\255\000\000\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\109\001\
\110\001\111\001\112\001\113\001\114\001\115\001\057\001\255\255\
\255\255\060\001\061\001\062\001\063\001\064\001\065\001\066\001\
\067\001\068\001\069\001\070\001\071\001\072\001\073\001\255\255\
\075\001\076\001\077\001\255\255\255\255\255\255\081\001\082\001\
\255\255\255\255\085\001\086\001\255\255\255\255\255\255\090\001\
\255\255\092\001\093\001\035\001\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\109\001\110\001\111\001\112\001\113\001\114\001\
\115\001\057\001\255\255\255\255\060\001\061\001\062\001\063\001\
\064\001\065\001\066\001\067\001\068\001\069\001\070\001\071\001\
\072\001\073\001\255\255\075\001\076\001\077\001\255\255\255\255\
\255\255\081\001\082\001\255\255\255\255\085\001\086\001\255\255\
\255\255\255\255\090\001\255\255\092\001\093\001\035\001\255\255\
\255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\109\001\110\001\111\001\
\112\001\113\001\114\001\115\001\057\001\058\001\255\255\060\001\
\061\001\062\001\063\001\064\001\065\001\066\001\067\001\068\001\
\069\001\070\001\071\001\072\001\073\001\255\255\075\001\076\001\
\077\001\255\255\255\255\255\255\081\001\082\001\255\255\255\255\
\085\001\255\255\255\255\255\255\255\255\090\001\255\255\092\001\
\093\001\035\001\255\255\255\255\255\255\000\000\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\109\001\110\001\111\001\112\001\113\001\114\001\115\001\057\001\
\058\001\255\255\060\001\061\001\062\001\063\001\064\001\065\001\
\066\001\067\001\068\001\069\001\070\001\071\001\072\001\073\001\
\255\255\075\001\076\001\077\001\255\255\255\255\255\255\081\001\
\082\001\255\255\255\255\085\001\255\255\255\255\255\255\255\255\
\090\001\255\255\092\001\093\001\035\001\255\255\000\000\255\255\
\000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\109\001\110\001\111\001\112\001\113\001\
\114\001\115\001\057\001\255\255\255\255\060\001\061\001\062\001\
\063\001\064\001\065\001\066\001\067\001\068\001\069\001\070\001\
\071\001\072\001\073\001\255\255\075\001\076\001\077\001\255\255\
\255\255\255\255\081\001\082\001\255\255\255\255\085\001\086\001\
\255\255\255\255\255\255\090\001\255\255\092\001\093\001\035\001\
\255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\109\001\110\001\
\111\001\112\001\113\001\114\001\115\001\057\001\255\255\255\255\
\060\001\061\001\062\001\063\001\064\001\065\001\066\001\067\001\
\068\001\069\001\070\001\255\255\255\255\255\255\255\255\075\001\
\076\001\077\001\255\255\255\255\255\255\081\001\082\001\255\255\
\255\255\085\001\086\001\255\255\255\255\255\255\090\001\255\255\
\092\001\093\001\035\001\255\255\255\255\255\255\000\000\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\109\001\110\001\111\001\112\001\113\001\114\001\115\001\
\057\001\255\255\255\255\060\001\061\001\062\001\063\001\064\001\
\065\001\066\001\067\001\068\001\069\001\070\001\255\255\255\255\
\255\255\255\255\075\001\076\001\077\001\255\255\255\255\255\255\
\081\001\082\001\255\255\255\255\085\001\086\001\255\255\255\255\
\255\255\090\001\255\255\092\001\093\001\035\001\255\255\255\255\
\255\255\000\000\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\109\001\110\001\111\001\112\001\
\113\001\114\001\115\001\057\001\255\255\255\255\060\001\061\001\
\062\001\063\001\064\001\065\001\066\001\067\001\068\001\069\001\
\070\001\255\255\255\255\255\255\255\255\075\001\076\001\077\001\
\255\255\255\255\255\255\081\001\082\001\255\255\255\255\085\001\
\086\001\255\255\255\255\255\255\090\001\255\255\092\001\093\001\
\035\001\255\255\255\255\255\255\000\000\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\109\001\
\110\001\111\001\112\001\113\001\114\001\115\001\057\001\001\001\
\255\255\060\001\061\001\062\001\063\001\064\001\065\001\066\001\
\067\001\068\001\069\001\070\001\255\255\255\255\255\255\255\255\
\075\001\076\001\077\001\255\255\255\255\255\255\081\001\082\001\
\255\255\255\255\085\001\086\001\255\255\255\255\255\255\090\001\
\255\255\092\001\093\001\035\001\255\255\255\255\255\255\000\000\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\109\001\110\001\111\001\112\001\113\001\114\001\
\115\001\057\001\255\255\255\255\060\001\061\001\062\001\063\001\
\064\001\065\001\066\001\067\001\068\001\071\001\255\255\255\255\
\255\255\255\255\255\255\075\001\076\001\077\001\255\255\255\255\
\255\255\081\001\082\001\085\001\086\001\085\001\086\001\089\001\
\255\255\255\255\090\001\093\001\092\001\093\001\035\001\255\255\
\255\255\255\255\000\000\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\109\001\110\001\111\001\
\112\001\113\001\114\001\115\001\057\001\255\255\255\255\060\001\
\061\001\062\001\063\001\064\001\065\001\066\001\067\001\068\001\
\255\255\255\255\255\255\255\255\255\255\255\255\075\001\076\001\
\077\001\255\255\255\255\255\255\081\001\082\001\255\255\255\255\
\085\001\086\001\255\255\255\255\255\255\090\001\255\255\092\001\
\093\001\035\001\255\255\255\255\255\255\000\000\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\109\001\110\001\111\001\112\001\113\001\114\001\115\001\057\001\
\255\255\255\255\060\001\061\001\062\001\063\001\064\001\065\001\
\066\001\067\001\068\001\255\255\255\255\255\255\255\255\255\255\
\255\255\075\001\076\001\077\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\085\001\086\001\255\255\255\255\255\255\
\090\001\255\255\092\001\093\001\035\001\255\255\255\255\255\255\
\000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\109\001\110\001\111\001\112\001\113\001\
\114\001\115\001\057\001\255\255\255\255\060\001\061\001\062\001\
\063\001\064\001\065\001\066\001\067\001\068\001\255\255\255\255\
\255\255\255\255\255\255\255\255\075\001\076\001\077\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\085\001\086\001\
\255\255\255\255\255\255\090\001\255\255\092\001\093\001\035\001\
\255\255\255\255\255\255\000\000\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\109\001\110\001\
\111\001\112\001\113\001\114\001\115\001\057\001\255\255\255\255\
\060\001\061\001\062\001\063\001\064\001\065\001\066\001\067\001\
\068\001\255\255\255\255\255\255\255\255\255\255\255\255\075\001\
\076\001\077\001\255\255\000\000\255\255\255\255\255\255\255\255\
\255\255\085\001\086\001\255\255\255\255\255\255\090\001\255\255\
\092\001\093\001\035\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\109\001\110\001\111\001\112\001\113\001\114\001\115\001\
\057\001\255\255\255\255\060\001\061\001\062\001\063\001\064\001\
\065\001\066\001\067\001\068\001\255\255\255\255\255\255\255\255\
\255\255\255\255\075\001\076\001\077\001\255\255\000\000\255\255\
\255\255\255\255\255\255\255\255\085\001\086\001\255\255\255\255\
\255\255\090\001\255\255\092\001\093\001\035\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\109\001\110\001\111\001\112\001\
\113\001\114\001\115\001\057\001\255\255\255\255\060\001\061\001\
\255\255\255\255\255\255\255\255\066\001\067\001\068\001\255\255\
\255\255\255\255\255\255\255\255\255\255\075\001\076\001\077\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\085\001\
\086\001\255\255\255\255\255\255\090\001\255\255\092\001\093\001\
\035\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\109\001\
\110\001\111\001\112\001\113\001\114\001\115\001\057\001\255\255\
\255\255\060\001\061\001\255\255\255\255\255\255\255\255\066\001\
\067\001\068\001\255\255\255\255\255\255\255\255\255\255\255\255\
\075\001\076\001\077\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\085\001\086\001\255\255\255\255\255\255\090\001\
\255\255\092\001\093\001\035\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\057\001\109\001\110\001\111\001\112\001\113\001\114\001\
\115\001\057\001\066\001\067\001\068\001\255\255\255\255\255\255\
\255\255\255\255\066\001\067\001\068\001\255\255\255\255\255\255\
\255\255\255\255\255\255\075\001\076\001\077\001\086\001\255\255\
\255\255\255\255\255\255\255\255\255\255\085\001\086\001\255\255\
\255\255\255\255\090\001\255\255\092\001\093\001\035\001\255\255\
\255\255\255\255\255\255\255\255\255\255\109\001\110\001\111\001\
\112\001\113\001\114\001\115\001\255\255\109\001\110\001\111\001\
\112\001\113\001\114\001\115\001\057\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\066\001\067\001\068\001\
\255\255\255\255\255\255\255\255\255\255\255\255\035\001\076\001\
\077\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\085\001\086\001\255\255\255\255\255\255\090\001\255\255\092\001\
\093\001\255\255\255\255\255\255\057\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\066\001\067\001\068\001\
\109\001\110\001\111\001\112\001\113\001\114\001\115\001\076\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\085\001\086\001\255\255\255\255\255\255\090\001\255\255\092\001\
\093\001\035\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\109\001\110\001\111\001\112\001\113\001\114\001\115\001\255\255\
\058\001\255\255\060\001\061\001\062\001\063\001\064\001\065\001\
\002\000\255\255\255\255\069\001\070\001\071\001\072\001\073\001\
\035\001\075\001\076\001\077\001\255\255\255\255\255\255\081\001\
\082\001\019\000\020\000\021\000\022\000\023\000\024\000\025\000\
\026\000\027\000\255\255\255\255\255\255\031\000\255\255\058\001\
\255\255\060\001\061\001\062\001\063\001\064\001\065\001\255\255\
\255\255\255\255\069\001\070\001\071\001\072\001\073\001\255\255\
\075\001\076\001\077\001\053\000\255\255\255\255\081\001\082\001\
\255\255\058\001\255\255\060\001\061\001\062\001\063\001\064\001\
\065\001\067\000\093\001\255\255\069\001\070\001\071\001\072\001\
\073\001\255\255\075\001\077\000\077\001\079\000\255\255\255\255\
\081\001\082\001\255\255\255\255\255\255\087\000\255\255\255\255\
\255\255\255\255\092\000\093\000\094\000\095\000\096\000\097\000\
\098\000\099\000\100\000\101\000\102\000\103\000\104\000\105\000\
\106\000\107\000\108\000\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\119\000\255\255\255\255\
\255\255\255\255\255\255\255\255\035\001\255\255\255\255\255\255\
\130\000\131\000\132\000\133\000\134\000\135\000\136\000\137\000\
\138\000\139\000\140\000\141\000\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\149\000\150\000\060\001\061\001\062\001\
\063\001\064\001\065\001\255\255\158\000\255\255\069\001\070\001\
\071\001\072\001\073\001\255\255\075\001\076\001\077\001\255\255\
\255\255\255\255\081\001\082\001\255\255\255\255\255\255\255\255\
\255\255\001\001\255\255\003\001\255\255\255\255\255\255\255\255\
\008\001\009\001\010\001\011\001\012\001\255\255\255\255\255\255\
\016\001\255\255\018\001\255\255\020\001\021\001\022\001\023\001\
\255\255\255\255\204\000\255\255\255\255\255\255\255\255\031\001\
\210\000\211\000\034\001\255\255\036\001\037\001\038\001\039\001\
\040\001\219\000\255\255\255\255\222\000\255\255\046\001\047\001\
\226\000\049\001\255\255\255\255\052\001\053\001\054\001\055\001\
\056\001\255\255\255\255\255\255\238\000\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\069\001\070\001\071\001\
\255\255\255\255\074\001\075\001\255\255\255\255\078\001\255\255\
\255\255\255\255\255\255\255\255\006\001\255\255\086\001\255\255\
\088\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\096\001\097\001\255\255\099\001\255\255\255\255\255\255\103\001\
\255\255\001\001\106\001\003\001\255\255\255\255\255\255\255\255\
\008\001\009\001\010\001\011\001\012\001\255\255\255\255\119\001\
\016\001\255\255\018\001\255\255\020\001\021\001\022\001\023\001\
\255\255\255\255\255\255\255\255\001\001\255\255\003\001\031\001\
\255\255\255\255\034\001\255\255\036\001\037\001\255\255\039\001\
\255\255\255\255\255\255\043\001\255\255\255\255\046\001\047\001\
\255\255\255\255\255\255\255\255\255\255\255\255\054\001\055\001\
\056\001\255\255\031\001\255\255\255\255\034\001\255\255\255\255\
\037\001\038\001\039\001\040\001\255\255\069\001\070\001\071\001\
\255\255\046\001\074\001\075\001\049\001\255\255\078\001\052\001\
\255\255\054\001\055\001\056\001\255\255\255\255\086\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\069\001\070\001\071\001\255\255\255\255\074\001\075\001\255\255\
\001\001\078\001\003\001\255\255\255\255\255\255\255\255\255\255\
\255\255\086\001\255\255\088\001\255\255\255\255\255\255\119\001\
\255\255\255\255\255\255\096\001\097\001\255\255\099\001\255\255\
\255\255\255\255\103\001\255\255\255\255\106\001\031\001\255\255\
\255\255\034\001\255\255\255\255\037\001\038\001\039\001\040\001\
\255\255\255\255\255\255\255\255\255\255\046\001\255\255\255\255\
\001\001\255\255\003\001\255\255\058\001\054\001\055\001\056\001\
\062\001\063\001\064\001\065\001\255\255\255\255\255\255\069\001\
\070\001\071\001\072\001\073\001\069\001\070\001\071\001\255\255\
\255\255\074\001\075\001\081\001\082\001\078\001\031\001\032\001\
\255\255\034\001\255\255\255\255\037\001\086\001\039\001\255\255\
\255\255\255\255\255\255\255\255\255\255\046\001\001\001\255\255\
\003\001\255\255\255\255\255\255\255\255\054\001\055\001\056\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\069\001\070\001\071\001\255\255\
\255\255\074\001\075\001\255\255\031\001\078\001\033\001\034\001\
\255\255\255\255\037\001\255\255\039\001\086\001\255\255\255\255\
\001\001\255\255\003\001\046\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\054\001\055\001\056\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\069\001\070\001\071\001\255\255\031\001\074\001\
\075\001\034\001\255\255\078\001\037\001\255\255\039\001\255\255\
\255\255\255\255\001\001\086\001\003\001\046\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\054\001\055\001\056\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\069\001\070\001\071\001\255\255\
\031\001\074\001\075\001\034\001\255\255\078\001\037\001\255\255\
\039\001\255\255\255\255\255\255\001\001\086\001\003\001\046\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\054\001\
\055\001\056\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\069\001\070\001\
\071\001\255\255\031\001\074\001\075\001\034\001\255\255\078\001\
\037\001\255\255\039\001\255\255\255\255\255\255\255\255\086\001\
\255\255\046\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\054\001\055\001\056\001\255\255\255\255\255\255\255\255\
\255\255\035\001\255\255\255\255\255\255\255\255\255\255\255\255\
\069\001\070\001\071\001\255\255\255\255\074\001\075\001\255\255\
\255\255\078\001\255\255\255\255\255\255\255\255\255\255\255\255\
\058\001\086\001\060\001\061\001\062\001\063\001\064\001\065\001\
\255\255\255\255\035\001\069\001\070\001\071\001\072\001\073\001\
\255\255\075\001\076\001\077\001\255\255\255\255\255\255\081\001\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\058\001\092\001\060\001\061\001\062\001\063\001\064\001\
\065\001\255\255\255\255\035\001\069\001\070\001\071\001\072\001\
\073\001\255\255\075\001\076\001\077\001\255\255\255\255\255\255\
\081\001\082\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\058\001\092\001\060\001\061\001\062\001\063\001\
\064\001\065\001\255\255\255\255\035\001\069\001\070\001\071\001\
\072\001\073\001\255\255\075\001\076\001\077\001\255\255\255\255\
\255\255\081\001\082\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\058\001\092\001\060\001\061\001\062\001\
\063\001\064\001\065\001\255\255\255\255\035\001\069\001\070\001\
\071\001\072\001\073\001\255\255\075\001\076\001\077\001\255\255\
\255\255\255\255\081\001\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\058\001\092\001\060\001\061\001\
\062\001\063\001\064\001\065\001\255\255\255\255\035\001\069\001\
\070\001\071\001\072\001\073\001\255\255\075\001\076\001\077\001\
\255\255\255\255\255\255\081\001\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\058\001\092\001\060\001\
\061\001\062\001\063\001\064\001\065\001\255\255\255\255\035\001\
\069\001\070\001\071\001\072\001\073\001\255\255\075\001\076\001\
\077\001\255\255\255\255\255\255\081\001\082\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\058\001\092\001\
\060\001\061\001\062\001\063\001\064\001\065\001\255\255\255\255\
\035\001\069\001\070\001\071\001\072\001\073\001\255\255\075\001\
\076\001\077\001\255\255\255\255\255\255\081\001\082\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\058\001\
\092\001\060\001\061\001\062\001\063\001\064\001\065\001\255\255\
\255\255\035\001\069\001\070\001\071\001\072\001\073\001\255\255\
\075\001\076\001\077\001\255\255\255\255\255\255\081\001\082\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\058\001\092\001\060\001\061\001\062\001\063\001\064\001\065\001\
\255\255\255\255\035\001\069\001\070\001\071\001\072\001\073\001\
\255\255\075\001\076\001\077\001\255\255\255\255\255\255\081\001\
\082\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\058\001\092\001\060\001\061\001\062\001\063\001\064\001\
\065\001\255\255\255\255\035\001\069\001\070\001\071\001\072\001\
\073\001\255\255\075\001\076\001\077\001\255\255\255\255\255\255\
\081\001\082\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\058\001\092\001\060\001\061\001\062\001\063\001\
\064\001\065\001\255\255\255\255\035\001\069\001\070\001\071\001\
\072\001\073\001\255\255\075\001\076\001\077\001\255\255\255\255\
\255\255\081\001\082\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\058\001\092\001\060\001\061\001\062\001\
\063\001\064\001\065\001\255\255\255\255\035\001\069\001\070\001\
\071\001\072\001\073\001\255\255\075\001\076\001\077\001\255\255\
\255\255\255\255\081\001\082\001\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\058\001\092\001\060\001\061\001\
\062\001\063\001\064\001\065\001\035\001\255\255\255\255\069\001\
\070\001\071\001\072\001\073\001\255\255\075\001\076\001\077\001\
\255\255\255\255\255\255\081\001\082\001\255\255\255\255\255\255\
\255\255\255\255\255\255\058\001\090\001\060\001\061\001\062\001\
\063\001\064\001\065\001\035\001\255\255\255\255\069\001\070\001\
\071\001\072\001\073\001\255\255\075\001\076\001\077\001\255\255\
\255\255\255\255\081\001\082\001\255\255\255\255\085\001\255\255\
\255\255\255\255\058\001\255\255\060\001\061\001\062\001\063\001\
\064\001\065\001\035\001\255\255\255\255\069\001\070\001\071\001\
\072\001\073\001\255\255\075\001\076\001\077\001\255\255\255\255\
\255\255\081\001\082\001\255\255\255\255\085\001\255\255\255\255\
\255\255\058\001\255\255\060\001\061\001\062\001\063\001\064\001\
\065\001\035\001\255\255\255\255\069\001\070\001\071\001\072\001\
\073\001\255\255\075\001\076\001\077\001\255\255\255\255\255\255\
\081\001\082\001\255\255\255\255\085\001\255\255\255\255\255\255\
\058\001\255\255\060\001\061\001\062\001\063\001\064\001\065\001\
\035\001\255\255\255\255\069\001\070\001\071\001\072\001\073\001\
\255\255\075\001\076\001\077\001\255\255\255\255\255\255\081\001\
\082\001\255\255\255\255\085\001\255\255\255\255\255\255\058\001\
\255\255\060\001\061\001\062\001\063\001\064\001\065\001\035\001\
\255\255\255\255\069\001\070\001\071\001\072\001\073\001\255\255\
\075\001\076\001\077\001\255\255\255\255\255\255\081\001\082\001\
\255\255\255\255\255\255\255\255\255\255\255\255\058\001\255\255\
\060\001\061\001\062\001\063\001\064\001\065\001\255\255\255\255\
\255\255\069\001\070\001\071\001\072\001\073\001\255\255\075\001\
\076\001\077\001\255\255\255\255\255\255\081\001\082\001\058\001\
\255\255\060\001\061\001\062\001\063\001\064\001\065\001\255\255\
\255\255\255\255\069\001\070\001\071\001\072\001\073\001\255\255\
\075\001\076\001\077\001\255\255\255\255\255\255\081\001\082\001\
\058\001\255\255\060\001\061\001\062\001\063\001\064\001\065\001\
\255\255\255\255\255\255\069\001\070\001\071\001\072\001\073\001\
\255\255\075\001\255\255\255\255\255\255\255\255\255\255\081\001\
\082\001\058\001\255\255\060\001\061\001\062\001\063\001\064\001\
\065\001\255\255\255\255\255\255\069\001\070\001\071\001\072\001\
\073\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\081\001\082\001"

let yynames_const = "\
  EOF\000\
  CHAR\000\
  INT\000\
  DOUBLE\000\
  FLOAT\000\
  VOID\000\
  INT64\000\
  INT32\000\
  ENUM\000\
  STRUCT\000\
  TYPEDEF\000\
  UNION\000\
  SIGNED\000\
  UNSIGNED\000\
  LONG\000\
  SHORT\000\
  INT128\000\
  VOLATILE\000\
  EXTERN\000\
  STATIC\000\
  CONST\000\
  RESTRICT\000\
  AUTO\000\
  REGISTER\000\
  SIZEOF\000\
  ALIGNOF\000\
  EQ\000\
  ARROW\000\
  DOT\000\
  EQ_EQ\000\
  EXCLAM_EQ\000\
  INF\000\
  SUP\000\
  INF_EQ\000\
  SUP_EQ\000\
  MINUS_EQ\000\
  PLUS_EQ\000\
  STAR_EQ\000\
  PLUS\000\
  MINUS\000\
  STAR\000\
  SLASH\000\
  PERCENT\000\
  TILDE\000\
  AND\000\
  PIPE\000\
  CIRC\000\
  EXCLAM\000\
  AND_AND\000\
  PIPE_PIPE\000\
  INF_INF\000\
  SUP_SUP\000\
  PLUS_PLUS\000\
  MINUS_MINUS\000\
  RPAREN\000\
  LPAREN\000\
  RBRACE\000\
  LBRACE\000\
  LBRACKET\000\
  RBRACKET\000\
  COLON\000\
  SEMICOLON\000\
  COMMA\000\
  ELLIPSIS\000\
  QUEST\000\
  BREAK\000\
  CONTINUE\000\
  GOTO\000\
  RETURN\000\
  SWITCH\000\
  CASE\000\
  DEFAULT\000\
  WHILE\000\
  DO\000\
  FOR\000\
  IF\000\
  THEN\000\
  ELSE\000\
  SLASH_EQ\000\
  PERCENT_EQ\000\
  AND_EQ\000\
  PIPE_EQ\000\
  CIRC_EQ\000\
  INF_INF_EQ\000\
  SUP_SUP_EQ\000\
  ATTRIBUTE\000\
  INLINE\000\
  ASM\000\
  TYPEOF\000\
  FUNCTION__\000\
  PRETTY_FUNCTION__\000\
  LABEL__\000\
  BUILTIN_VA_ARG\000\
  BUILTIN_VA_LIST\000\
  BLOCKATTRIBUTE\000\
  DECLSPEC\000\
  PRAGMA\000\
  "

let yynames_block = "\
  IDENT\000\
  CST_CHAR\000\
  CST_INT\000\
  CST_FLOAT\000\
  CST_STRING\000\
  CST_WSTRING\000\
  NAMED_TYPE\000\
  ARG_e\000\
  ARG_eo\000\
  ARG_E\000\
  ARG_u\000\
  ARG_b\000\
  ARG_t\000\
  ARG_d\000\
  ARG_lo\000\
  ARG_l\000\
  ARG_i\000\
  ARG_o\000\
  ARG_va\000\
  ARG_f\000\
  ARG_F\000\
  ARG_A\000\
  ARG_v\000\
  ARG_k\000\
  ARG_c\000\
  ARG_s\000\
  ARG_p\000\
  ARG_P\000\
  ARG_I\000\
  ARG_S\000\
  ARG_g\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    Obj.repr(
# 334 "src/formatparse.mly"
               (  )
# 1666 "src/formatparse.ml"
               : unit))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 341 "src/formatparse.mly"
                       (  (* Count arguments eagerly *)
                            let currentArg = _1 in
                            ((fun args ->
                               match getArg currentArg args with
                                   Fe e -> e
                                 | a -> wrongArgType currentArg
                                            "expression" a),

                             (fun e -> Some [ Fe e ]))
                         )
# 1682 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 352 "src/formatparse.mly"
                   ( _1 )
# 1689 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    Obj.repr(
# 355 "src/formatparse.mly"
                        ( ((fun args -> Lval ((fst _1) args)),

                             (fun e -> match e with
                                Lval l -> (snd _1) l
                              | _ -> None))
                         )
# 1701 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 363 "src/formatparse.mly"
          ( ((fun args -> SizeOfE ((fst _2) args)),

                           fun e -> match e with
                             SizeOfE e' -> (snd _2) e'
                           | _ -> None)
                        )
# 1713 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)) in
    Obj.repr(
# 371 "src/formatparse.mly"
                        ( ((fun args -> SizeOf ((fst _3) args)),

                           (fun e -> match e with
                              SizeOf t -> (snd _3) t
                           |  _ -> None))
                        )
# 1725 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 379 "src/formatparse.mly"
          ( ((fun args -> AlignOfE ((fst _2) args)),

                           (fun e -> match e with
                             AlignOfE e' -> (snd _2) e' | _ -> None))
                        )
# 1736 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)) in
    Obj.repr(
# 386 "src/formatparse.mly"
          ( ((fun args -> AlignOf ((fst _3) args)),

                           (fun e -> match e with
                             AlignOf t' -> (snd _3) t' | _ -> None))
                        )
# 1747 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 393 "src/formatparse.mly"
          ( _2 )
# 1754 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 395 "src/formatparse.mly"
          ( doUnop Neg _2 )
# 1761 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 398 "src/formatparse.mly"
          ( doUnop LNot _2 )
# 1768 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 401 "src/formatparse.mly"
          ( doUnop BNot _2 )
# 1775 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'argu) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 404 "src/formatparse.mly"
                        ( ((fun args ->
                             let e = (fst _2) args in
                             UnOp((fst _1) args, e, typeOf e)),

                           (fun e -> match e with
                             UnOp(uo, e', _) -> begin
                               match (snd _1) uo, (snd _2) e' with
                                 Some m1, Some m2 -> Some (m1 @ m2)
                               | _ -> None
                             end
                           | _ -> None))
                        )
# 1794 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 419 "src/formatparse.mly"
          ( ((fun args ->
                             match (fst _2) args with
                                Lval l -> mkAddrOf l
                              | _ -> E.s (bug "AddrOf applied to a non lval")),
                          (fun e -> match e with
                            AddrOf l -> (snd _2) (Lval l)
                          | e -> (snd _2) (Lval (mkMem ~addr:e ~off:NoOffset))))
                         )
# 1808 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 429 "src/formatparse.mly"
                        ( _2 )
# 1815 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 432 "src/formatparse.mly"
   ( ((fun args -> buildPlus ((fst _1) args)
                                                  ((fst _3) args)),
                          (fun e -> match e with
                            BinOp((PlusPI|PlusA), e1, e2, _) -> begin
                              match (snd _1) e1, (snd _3) e2 with
                                Some m1, Some m2 -> Some (m1 @ m2)
                              | _, _ -> None
                            end
                          | _ -> None))
                        )
# 1832 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 444 "src/formatparse.mly"
                        ( ((fun args -> buildMinus ((fst _1) args)
                                                   ((fst _3) args)),

                           (fun e -> match e with
                             BinOp((MinusPP|MinusPI|MinusA), e1, e2, _) ->
                               begin
                                 match (snd _1) e1, (snd _3) e2 with
                                   Some m1, Some m2 -> Some (m1 @ m2)
                                 | _, _ -> None
                               end
                           | _ -> None))
                        )
# 1851 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'argb) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 457 "src/formatparse.mly"
                        ( ((fun args ->
                               let e1 = (fst _1) args in
                               let bop = (fst _2) args in
                               let e2 = (fst _3) args in
                               let t1 = typeOf e1 in
                               BinOp(bop, e1, e2, t1)),

                           (fun e -> match e with
                             BinOp(bop, e1, e2, _) -> begin
                               match (snd _1) e1,(snd _2) bop,(snd _3) e2 with
                                 Some m1, Some m2, Some m3 ->
                                   Some (m1 @ m2 @ m3)
                               | _, _, _ -> None
                             end
                           | _ -> None))
                        )
# 1875 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 475 "src/formatparse.mly"
   ( doBinop Mult _1 _3 )
# 1883 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 477 "src/formatparse.mly"
   ( doBinop Div _1 _3 )
# 1891 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 479 "src/formatparse.mly"
   ( doBinop Mod _1 _3 )
# 1899 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 481 "src/formatparse.mly"
   ( doBinop Shiftlt _1 _3 )
# 1907 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 483 "src/formatparse.mly"
   ( doBinop Shiftrt _1 _3 )
# 1915 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 485 "src/formatparse.mly"
   ( doBinop BAnd _1 _3 )
# 1923 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 487 "src/formatparse.mly"
   ( doBinop BOr _1 _3 )
# 1931 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 489 "src/formatparse.mly"
   ( doBinop BXor _1 _3 )
# 1939 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 491 "src/formatparse.mly"
   ( doBinop Eq _1 _3 )
# 1947 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 493 "src/formatparse.mly"
   ( doBinop Ne _1 _3 )
# 1955 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 495 "src/formatparse.mly"
   ( doBinop Lt _1 _3 )
# 1963 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 497 "src/formatparse.mly"
   ( doBinop Gt _1 _3 )
# 1971 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 499 "src/formatparse.mly"
   ( doBinop Le _1 _3 )
# 1979 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 501 "src/formatparse.mly"
   ( doBinop Ge _1 _3 )
# 1987 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 504 "src/formatparse.mly"
           ( ((fun args ->
                              let t = (fst _2) args in
                              let e = (fst _4) args in
                              mkCast ~e:e ~newt:t),

                            (fun e ->
                              let t', e' =
                                match e with
                                  CastE (t', e') -> t', e'
                                | _ -> typeOf e, e
                              in
                              match (snd _2) t', (snd _4 e') with
                                Some m1, Some m2 -> Some (m1 @ m2)
                              | _, _ -> None))
                         )
# 2009 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 523 "src/formatparse.mly"
                       ( let currentArg = _1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fu uo -> uo
                           | a -> wrongArgType currentArg "unnop" a),

                          fun uo -> Some [ Fu uo ])
                       )
# 2023 "src/formatparse.ml"
               : 'argu))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 534 "src/formatparse.mly"
                       ( let currentArg = _1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fb bo -> bo
                           | a -> wrongArgType currentArg "binop" a),

                          fun bo -> Some [ Fb bo ])
                       )
# 2037 "src/formatparse.ml"
               : 'argb))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 545 "src/formatparse.mly"
                       ( let currentArg = _1 in
                           ((fun args ->
                             match getArg currentArg args with
                               Fd n -> integer n
                              | a -> wrongArgType currentArg "integer" a),

                            fun e -> match e with
                              Const(CInt(n, _, _)) ->
                                Some [ Fd (Cilint.int_of_cilint n) ]
                            | _ -> None)
                         )
# 2054 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 557 "src/formatparse.mly"
                      ( let currentArg = _1 in
                        ((fun args ->
                             match getArg currentArg args with
                               Fg s -> Const(CStr (s, No_encoding))
                              | a -> wrongArgType currentArg "string" a),

                            fun e -> match e with
                              Const(CStr (s,_)) ->
                                Some [ Fg s ]
                            | _ -> None)
                         )
# 2071 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 568 "src/formatparse.mly"
                         ( let n = parseInt _1 in
                           ((fun args -> n),

                            (fun e -> match e, n with
                              Const(CInt(e', _, _)),
                              Const(CInt(n', _, _)) when e' = n' -> Some []
                            | _ -> None))
                         )
# 2085 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 581 "src/formatparse.mly"
                      ( let currentArg = _1 in
                           ((fun args ->
                                match getArg currentArg args with
                                  Fl l -> l
                                | Fv v -> Var v, NoOffset
                                | a -> wrongArgType currentArg "lval" a),

                            fun l -> Some [ Fl l ])
                         )
# 2100 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'argv) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : (Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option)) in
    Obj.repr(
# 592 "src/formatparse.mly"
                         ( ((fun args ->
                              let v = (fst _1) args in
                               (Var v, (fst _2) v.vtype args)),

                            (fun l -> match l with
                              Var vi, off -> begin
                                match (snd _1) vi, (snd _2) off with
                                  Some m1, Some m2 -> Some (m1 @ m2)
                                | _ -> None
                              end
                            | _ -> None))
                         )
# 2119 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 605 "src/formatparse.mly"
                         ( ((fun args -> mkMem ~addr:((fst _2) args) ~off:NoOffset),

                           (fun l -> match l with
                              Mem e, NoOffset -> (snd _2) e
                           | _, _ -> None))
                         )
# 2131 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : (Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option)) in
    Obj.repr(
# 613 "src/formatparse.mly"
             ( ((fun args ->
                   let e = (fst _1) args in
                   let baset =
                     match unrollTypeDeep (typeOf e) with
                       TPtr (t, _) -> t
                     | _ -> E.s (bug "Expecting a pointer for field %s\n" _3)
                   in
                   let fi = getField baset _3 in
                   mkMem ~addr:e ~off:(Field(fi, (fst _4) fi.ftype args))),

                (fun l -> match l with
                   Mem e, Field(fi, off) when fi.fname = _3 -> begin
                     match (snd _1) e, (snd _4) off with
                       Some m1, Some m2 -> Some (m1 @ m2)
                     | _, _ -> None
                   end
                | _, _ -> None))
             )
# 2157 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : (Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option)) in
    Obj.repr(
# 633 "src/formatparse.mly"
             ( ((fun args ->
                 let e = (fst _3) args in
                 let baset =
                   match unrollTypeDeep (typeOf e) with
                     TPtr (t, _) -> t
                   | _ -> E.s (bug "Expecting a pointer\n")
                 in
                 mkMem ~addr:e ~off:((fst _5) baset args)),

                (fun l -> match l with
                  Mem e, off -> begin
                    match (snd _3) e, (snd _5 off) with
                      Some m1, Some m2 -> Some (m1 @ m2)
                    | _, _ -> None
                  end
                | _, _ -> None))
              )
# 2181 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 653 "src/formatparse.mly"
                       ( let currentArg = _1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fv v -> v
                           | a -> wrongArgType currentArg "varinfo" a),

                          fun v -> Some [ Fv v ])
                       )
# 2195 "src/formatparse.ml"
               : 'argv))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 661 "src/formatparse.mly"
                       ( let currentArg = _1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fv v -> v
                           | a -> wrongArgType currentArg "varinfo" a),
                         (fun v ->
                             E.s (bug "identifiers (%s) are not supported for deconstruction" currentArg)))
                       )
# 2209 "src/formatparse.ml"
               : 'argv))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 674 "src/formatparse.mly"
                     ( let currentArg = _1 in
                            ((fun t args ->
                                match getArg currentArg args with
                                  Fo o -> o
                                | a -> wrongArgType currentArg "offset" a),

                              (fun off -> Some [ Fo off ]))
                          )
# 2223 "src/formatparse.ml"
               : (Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 683 "src/formatparse.mly"
                          ( ((fun t args -> NoOffset),

                             (fun off -> match off with
                                NoOffset -> Some []
                              | _ -> None))
                          )
# 2234 "src/formatparse.ml"
               : (Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : (Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option)) in
    Obj.repr(
# 690 "src/formatparse.mly"
                          ( ((fun t args ->
                                let fi = getField t _2 in
                                Field (fi, (fst _3) fi.ftype args)),

                            (fun off -> match off with
                               Field (fi, off') when fi.fname = _2 ->
                                 (snd _3) off'
                            | _ -> None))
                          )
# 2250 "src/formatparse.ml"
               : (Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : (Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option)) in
    Obj.repr(
# 701 "src/formatparse.mly"
                   ( ((fun t args ->
                     let bt =
                       match unrollType t with
                         TArray(bt, _, _) -> bt
                       | _ -> E.s (error "Formatcil: expecting an array for index")
                     in
                     let e = (fst _2) args in
                     Index(e, (fst _4) bt args)),

                    (fun off -> match off with
                      Index (e, off') -> begin
                        match (snd _2) e, (snd _4) off with
                          Some m1, Some m2 -> Some (m1 @ m2)
                        | _, _ -> None
                      end
                    | _ -> None))
                    )
# 2274 "src/formatparse.ml"
               : (Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'one_formal) in
    Obj.repr(
# 722 "src/formatparse.mly"
                      ( ((fun args ->
                            let (_, ft, _) = (fst _1) args in
                            ft),

                         (fun t -> (snd _1) ("", t, [])))
                      )
# 2286 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'decl) in
    Obj.repr(
# 733 "src/formatparse.mly"
                   ( ((fun args ->
                        let tal = (fst _2) args in
                        let ts = (fst _1) tal args in
                        let (fn, ft, _) = (fst _3) ts args in
                        (fn, ft, [])),

                      (fun (fn, ft, fa) ->
                         match (snd _3) (fn, ft) with
                           Some (restt, m3) -> begin
                             match (snd _1) restt,
                                   (snd _2) (typeAttrs restt)with
                               Some m1, Some m2 ->
                                 Some (m1 @ m2 @ m3)
                             | _, _ -> None
                           end
                         | _ -> None))
                   )
# 2311 "src/formatparse.ml"
               : 'one_formal))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 752 "src/formatparse.mly"
                   ( let currentArg = _1 in
                     ((fun args ->
                         match getArg currentArg args with
                          Ff (fn, ft, fa) -> (fn, ft, fa)
                         | a  -> wrongArgType currentArg "formal" a),

                      (fun (fn, ft, fa) -> Some [ Ff (fn, ft, fa) ]))
                   )
# 2325 "src/formatparse.ml"
               : 'one_formal))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 763 "src/formatparse.mly"
                ( let currentArg = _1 in
                     ((fun al args ->
                       match getArg currentArg args with
                          Ft t -> typeAddAttributes al t
                       | a -> wrongArgType currentArg "type" a),

                      (fun t -> Some [ Ft t ]))
                      )
# 2339 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 772 "src/formatparse.mly"
                    ( ((fun al args -> TVoid al),

                       (fun t -> match unrollType t with
                           TVoid _ -> Some []
                         | _ -> None)) )
# 2349 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 778 "src/formatparse.mly"
                    ( let currentArg = _1 in
                      ((fun al args ->
                        match getArg currentArg args with
                          Fk ik -> TInt(ik, al)
                        | a -> wrongArgType currentArg "ikind" a),

                       (fun t -> match unrollType t with
                         TInt(ik, _) -> Some [ Fk ik ]
                       | _ -> None))
                    )
# 2365 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 789 "src/formatparse.mly"
                    ( ((fun al args -> TInt(IChar, al)),
                       (matchIntType IChar)) )
# 2372 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 791 "src/formatparse.mly"
                    ( ((fun al args -> TInt(IUChar, al)),
                       matchIntType IUChar) )
# 2379 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 794 "src/formatparse.mly"
                    ( ((fun al args -> TInt(IShort, al)),
                       matchIntType IShort) )
# 2386 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 796 "src/formatparse.mly"
                    ( ((fun al args -> TInt(IUShort, al)),
                       matchIntType IUShort) )
# 2393 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 799 "src/formatparse.mly"
                    ( ((fun al args -> TInt(IInt, al)),
                       matchIntType IInt) )
# 2400 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 801 "src/formatparse.mly"
                    ( ((fun al args -> TInt(IUInt, al)), matchIntType IUInt) )
# 2406 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 803 "src/formatparse.mly"
                     ( ((fun al args -> TInt(ILong, al)),
                        matchIntType ILong) )
# 2413 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 805 "src/formatparse.mly"
                     ( ((fun al args -> TInt(IULong, al)),
                        matchIntType IULong) )
# 2420 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 808 "src/formatparse.mly"
                       ( ((fun al args -> TInt(ILongLong, al)),

                          matchIntType ILongLong)
                        )
# 2429 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 812 "src/formatparse.mly"
                          ( ((fun al args -> TInt(IULongLong, al)),

                             matchIntType IULongLong)
                           )
# 2438 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 817 "src/formatparse.mly"
                    ( ((fun al args -> TInt(IInt128, al)),

                          matchIntType IInt128)
                        )
# 2447 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 821 "src/formatparse.mly"
                       ( ((fun al args -> TInt(IUInt128, al)),

                             matchIntType IUInt128)
                           )
# 2456 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 826 "src/formatparse.mly"
                    ( ((fun al args -> TFloat(FFloat, al)),
                       matchFloatType FFloat)
                    )
# 2464 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 829 "src/formatparse.mly"
                    ( ((fun al args -> TFloat(FDouble, al)),
                       matchFloatType FDouble) )
# 2471 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 832 "src/formatparse.mly"
                 ( let currentArg = _2 in
                      ((fun al args ->
                         match getArg currentArg args with
                           Fc ci -> TComp(ci, al)
                         | a -> wrongArgType currentArg "compinfo" a),

                        (fun t -> match unrollType t with
                            TComp(ci, _) -> Some [ Fc ci ]
                          | _ -> None))
                    )
# 2487 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 842 "src/formatparse.mly"
                ( let currentArg = _2 in
                     ((fun al args ->
                         match getArg currentArg args with
                           Fc ci -> TComp(ci, al)
                         | a -> wrongArgType currentArg "compinfo" a),

                        (fun t -> match unrollType t with
                            TComp(ci, _) -> Some [ Fc ci ]
                          | _ -> None))

                   )
# 2504 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 855 "src/formatparse.mly"
                   ( ((fun al args -> typeAddAttributes al
                                        (typeOf ((fst _3) args))),

                      (fun t -> E.s (bug "Cannot match typeof(e)\n")))
                   )
# 2515 "src/formatparse.ml"
               : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'decl) in
    Obj.repr(
# 864 "src/formatparse.mly"
                    ( ((fun ts args ->
                         let al = (fst _2) args in
                         (fst _3) (TPtr(ts, al)) args),

                       (fun (fn, ft) ->
                         match (snd _3) (fn, ft) with
                           Some (TPtr(bt, al), m2) -> begin
                             match (snd _2) al with
                               Some m1 -> Some (bt, m1 @ m2)
                             | _ -> None
                           end
                         | _ -> None))
                    )
# 2535 "src/formatparse.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'direct_decl) in
    Obj.repr(
# 878 "src/formatparse.mly"
                ( _1 )
# 2542 "src/formatparse.ml"
               : 'decl))
; (fun __caml_parser_env ->
    Obj.repr(
# 882 "src/formatparse.mly"
                   ( ((fun ts args -> ("", ts, [])),

                      (* Match any name in this case *)
                      (fun (fn, ft) ->
                         Some (unrollType ft, [])))
                   )
# 2553 "src/formatparse.ml"
               : 'direct_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 889 "src/formatparse.mly"
                   ( ((fun ts args -> (_1, ts, [])),

                      (fun (fn, ft) ->
                        if fn = "" || fn = _1 then
                          Some (unrollType ft, [])
                        else
                          None))
                   )
# 2567 "src/formatparse.ml"
               : 'direct_decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'decl) in
    Obj.repr(
# 899 "src/formatparse.mly"
                   ( ((fun ts args ->
                          let al = (fst _2) args in
                          (fst _3) (typeAddAttributes al ts) args),

                      (fun (fn, ft) -> begin
                        match (snd _3) (fn, ft) with
                          Some (restt, m2) -> begin
                            match (snd _2) (typeAttrs restt) with
                              Some m1 -> Some (restt, m1 @ m2)
                            | _ -> None
                          end
                        | _ -> None
                      end))
                   )
# 2588 "src/formatparse.ml"
               : 'direct_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'direct_decl) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'exp_opt) in
    Obj.repr(
# 915 "src/formatparse.mly"
                   ( ((fun ts args ->
                        (fst _1) (TArray(ts, (fst _3) args, [])) args),

                     (fun (fn, ft) ->
                       match (snd _1) (fn, ft) with
                         Some (TArray(bt, lo, _), m1) -> begin
                           match (snd _3) lo with
                             Some m2 -> Some (unrollType bt, m1 @ m2)
                           | _ -> None
                         end
                       | _ -> None))
                   )
# 2607 "src/formatparse.ml"
               : 'direct_decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 5 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'decl) in
    let _6 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> (string * Cil.typ * Cil.attributes) list option * bool) * ((string * Cil.typ * Cil.attributes) list option * bool -> Cil.formatArg list option)) in
    Obj.repr(
# 931 "src/formatparse.mly"
                   ( ((fun ts args ->
                        let al = (fst _2) args in
                        let pars, isva = (fst _6) args in
                        (fst _3) (TFun(ts, pars, isva, al)) args),

                      (fun (fn, ft) ->
                         match (snd _3) (fn, ft) with
                           Some (TFun(rt, args, isva, al), m1) -> begin
                             match (snd _2) al, (snd _6) (args, isva) with
                               Some m2, Some m6
                               -> Some (unrollType rt, m1 @ m2 @ m6)
                             | _ -> None
                           end
                         | _ -> None))
                   )
# 2630 "src/formatparse.ml"
               : 'direct_decl))
; (fun __caml_parser_env ->
    Obj.repr(
# 949 "src/formatparse.mly"
                   ( ((fun args -> (None, false)),

                     (* Match any formals *)
                      (fun (pars, isva) ->
                        match pars, isva with
                          (_, false) -> Some []
                        | _ -> None))
                   )
# 2643 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> (string * Cil.typ * Cil.attributes) list option * bool) * ((string * Cil.typ * Cil.attributes) list option * bool -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'parameters_ne) in
    Obj.repr(
# 958 "src/formatparse.mly"
                   ( ((fun args ->
                        let (pars : (string * typ * attributes) list),
                            (isva : bool) = (fst _1) args in
                        (Some pars), isva),

                     (function
                         ((Some pars), isva) -> (snd _1) (pars, isva)
                       |  _ -> None))
                   )
# 2658 "src/formatparse.ml"
               : ((string * Cil.formatArg) list -> (string * Cil.typ * Cil.attributes) list option * bool) * ((string * Cil.typ * Cil.attributes) list option * bool -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    Obj.repr(
# 970 "src/formatparse.mly"
                   ( ((fun args -> ([], true)),

                      (function
                          ([], true) -> Some []
                        | _ -> None))
                   )
# 2669 "src/formatparse.ml"
               : 'parameters_ne))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 977 "src/formatparse.mly"
                   ( let currentArg = _1 in
                     ((fun args ->
                       match getArg currentArg args with
                         Fva isva -> ([], isva)
                       | a -> wrongArgType currentArg "vararg" a),

                     (function
                         ([], isva) -> Some [ Fva isva ]
                       | _ -> None))
                   )
# 2685 "src/formatparse.ml"
               : 'parameters_ne))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 988 "src/formatparse.mly"
                   ( let currentArg = _1 in
                     ((fun args ->
                       match getArg currentArg args with
                        FF fl -> ( fl, false)
                       | a  -> wrongArgType currentArg "formals" a),

                      (function
                          (pars, false) -> Some [ FF pars ]
                        | _ -> None))
                   )
# 2701 "src/formatparse.ml"
               : 'parameters_ne))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'one_formal) in
    Obj.repr(
# 999 "src/formatparse.mly"
                   ( ((fun args -> ([(fst _1) args], false)),

                     (function
                         ([ f ], false) -> (snd _1) f
                       | _ -> None))
                   )
# 2713 "src/formatparse.ml"
               : 'parameters_ne))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'one_formal) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'parameters_ne) in
    Obj.repr(
# 1008 "src/formatparse.mly"
                   ( ((fun args ->
                        let this = (fst _1) args in
                        let (rest, isva) = (fst _3) args in
                        (this :: rest, isva)),

                      (function
                          ((f::rest, isva)) -> begin
                            match (snd _1) f, (snd _3) (rest, isva) with
                              Some m1, Some m2 -> Some (m1 @ m2)
                            | _, _ -> None
                          end
                        | _ -> None))
                   )
# 2733 "src/formatparse.ml"
               : 'parameters_ne))
; (fun __caml_parser_env ->
    Obj.repr(
# 1028 "src/formatparse.mly"
                   ( ((fun args -> None),
                      (* Match anything if the pattern does not have a len *)
                      (fun _ -> Some [])) )
# 2741 "src/formatparse.ml"
               : 'exp_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1032 "src/formatparse.mly"
                   ( ((fun args -> Some ((fst _1) args)),

                      (fun lo -> match lo with
                        Some e -> (snd _1) e
                      | _ -> None))
                   )
# 2753 "src/formatparse.ml"
               : 'exp_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1038 "src/formatparse.mly"
                   ( let currentArg = _1 in
                     ((fun args ->
                       match getArg currentArg args with
                         Feo lo -> lo
                       | a -> wrongArgType currentArg "exp_opt" a),

                      fun lo -> Some [ Feo lo ])
                   )
# 2767 "src/formatparse.ml"
               : 'exp_opt))
; (fun __caml_parser_env ->
    Obj.repr(
# 1052 "src/formatparse.mly"
                  ( ((fun args -> []),
                     (fun attrs -> Some [])) )
# 2774 "src/formatparse.ml"
               : 'attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1055 "src/formatparse.mly"
                  ( let currentArg = _1 in
                    ((fun args ->
                        match getArg currentArg args with
                          FA al -> al
                        | a -> wrongArgType currentArg "attributes" a),

                     (fun al -> Some [ FA al ]))
                  )
# 2788 "src/formatparse.ml"
               : 'attributes))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'attribute) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'attributes) in
    Obj.repr(
# 1065 "src/formatparse.mly"
                  ( ((fun args ->
                       addAttribute ((fst _1) args) ((fst _2) args)),
                     (* Pass all the attributes down *)
                     (fun attrs ->
                       match (snd _1) attrs, (snd _2) attrs with
                         Some m1, Some m2 -> Some (m1 @ m2)
                       | _, _ -> None))
                  )
# 2803 "src/formatparse.ml"
               : 'attributes))
; (fun __caml_parser_env ->
    Obj.repr(
# 1076 "src/formatparse.mly"
                                        ( doAttr "const" None )
# 2809 "src/formatparse.ml"
               : 'attribute))
; (fun __caml_parser_env ->
    Obj.repr(
# 1077 "src/formatparse.mly"
                                        ( doAttr "restrict" None )
# 2815 "src/formatparse.ml"
               : 'attribute))
; (fun __caml_parser_env ->
    Obj.repr(
# 1078 "src/formatparse.mly"
                                        ( doAttr "volatile" None )
# 2821 "src/formatparse.ml"
               : 'attribute))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'attr) in
    Obj.repr(
# 1080 "src/formatparse.mly"
                                        ( _4 )
# 2828 "src/formatparse.ml"
               : 'attribute))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1087 "src/formatparse.mly"
                          ( doAttr _1 None )
# 2835 "src/formatparse.ml"
               : 'attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'attr_args_ne) in
    Obj.repr(
# 1090 "src/formatparse.mly"
                          ( doAttr _1 (Some _3) )
# 2843 "src/formatparse.ml"
               : 'attr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'attr_arg) in
    Obj.repr(
# 1094 "src/formatparse.mly"
                                 ( ((fun args -> [ (fst _1) args ]),

                                    (fun aargs -> match aargs with
                                      [ arg ] -> (snd _1) arg
                                    | _ -> None))
                                 )
# 2855 "src/formatparse.ml"
               : 'attr_args_ne))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'attr_arg) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'attr_args_ne) in
    Obj.repr(
# 1100 "src/formatparse.mly"
                                 ( ((fun args ->
                                      let this = (fst _1) args in
                                      this :: ((fst _3) args)),

                                    (fun aargs -> match aargs with
                                      h :: rest -> begin
                                        match (snd _1) h, (snd _3) rest with
                                          Some m1, Some m2 -> Some (m1 @ m2)
                                        | _, _ -> None
                                      end
                                    | _ -> None))
                                  )
# 2874 "src/formatparse.ml"
               : 'attr_args_ne))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1112 "src/formatparse.mly"
                        ( let currentArg = _1 in
                          ((fun args ->
                            match getArg currentArg args with
                              FP al -> al
                            | a -> wrongArgType currentArg "attrparams" a),

                           (fun al -> Some [ FP al ]))
                        )
# 2888 "src/formatparse.ml"
               : 'attr_args_ne))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1123 "src/formatparse.mly"
                     ( ((fun args -> ACons(_1, [])),

                        (fun aarg -> match aarg with
                            ACons(id, []) when id = _1 -> Some []
                        | _ -> None))
                     )
# 2900 "src/formatparse.ml"
               : 'attr_arg))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'attr_args_ne) in
    Obj.repr(
# 1130 "src/formatparse.mly"
                     ( ((fun args -> ACons(_1, (fst _3) args)),

                        (fun aarg -> match aarg with
                            ACons(id, args) when id = _1 ->
                              (snd _3) args
                        | _ -> None))
                     )
# 2914 "src/formatparse.ml"
               : 'attr_arg))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1137 "src/formatparse.mly"
                     ( let currentArg = _1 in
                       ((fun args ->
                          match getArg currentArg args with
                            Fp p -> p
                          | a -> wrongArgType currentArg "attrparam" a),

                        (fun ap -> Some [ Fp ap]))
                     )
# 2928 "src/formatparse.ml"
               : 'attr_arg))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 1151 "src/formatparse.mly"
                        ( let currentArg = _1 in
                          ((fun loc args ->
                                match getArg currentArg args with
                                  Fi i -> i
                                | a -> wrongArgType currentArg "instr" a),

                           (fun i -> Some [ Fi i]))
                        )
# 2942 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1161 "src/formatparse.mly"
   ( ((fun loc args ->
                              Set((fst _1) args, (fst _3) args, loc, locUnknown)), (* TODO: better eloc? *)

                           (fun i -> match i with
                             Set (lv, e, l, el) -> begin
                               match (snd _1) lv, (snd _3) e with
                                 Some m1, Some m2 -> Some (m1 @ m2)
                               | _, _ -> None
                             end
                           | _ -> None))
                        )
# 2960 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1174 "src/formatparse.mly"
   ( ((fun loc args ->
                              let l = (fst _1) args in
                              Set(l, buildPlus (Lval l) ((fst _3) args), loc, locUnknown)), (* TODO: better eloc? *)

                           matchBinopEq
                             (fun bop -> bop = PlusPI || bop = PlusA)
                             (snd _1) (snd _3))
                        )
# 2975 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1184 "src/formatparse.mly"
   ( ((fun loc args ->
                              let l = (fst _1) args in
                              Set(l,
                                  buildMinus (Lval l) ((fst _3) args), loc, locUnknown)), (* TODO: better eloc? *)

                           matchBinopEq (fun bop -> bop = MinusA
                                               || bop = MinusPP
                                               || bop = MinusPI)
                                      (snd _1)  (snd _3))
                        )
# 2992 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1195 "src/formatparse.mly"
   ( doBinopEq Mult _1 _3 )
# 3000 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1198 "src/formatparse.mly"
   ( doBinopEq Div _1 _3 )
# 3008 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1201 "src/formatparse.mly"
   ( doBinopEq Mod _1 _3 )
# 3016 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1204 "src/formatparse.mly"
   ( doBinopEq BAnd _1 _3 )
# 3024 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1207 "src/formatparse.mly"
   ( doBinopEq BOr _1 _3 )
# 3032 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1210 "src/formatparse.mly"
   ( doBinopEq BXor _1 _3 )
# 3040 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1213 "src/formatparse.mly"
   ( doBinopEq Shiftlt _1 _3 )
# 3048 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1216 "src/formatparse.mly"
   ( doBinopEq Shiftrt _1 _3 )
# 3056 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 6 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 4 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'arguments) in
    Obj.repr(
# 1221 "src/formatparse.mly"
   ( ((fun loc args ->
                              Call(Some ((fst _1) args), Lval ((fst _3) args),
                                     (fst _5) args, loc, locUnknown)), (* TODO: better eloc? *)

                           (fun i -> match i with
                             Call(Some l, Lval f, args, loc, eloc) -> begin
                               match (snd _1) l, (snd _3) f, (snd _5) args with
                                 Some m1, Some m2, Some m3 ->
                                   Some (m1 @ m2 @ m3)
                               | _, _, _ -> None
                             end
                           | _ -> None))
                        )
# 3077 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'arguments) in
    Obj.repr(
# 1236 "src/formatparse.mly"
   ( ((fun loc args ->
                              Call(None, Lval ((fst _1) args),
                                     (fst _3) args, loc, locUnknown)), (* TODO: better eloc? *)

                           (fun i -> match i with
                             Call(None, Lval f, args, loc, eloc) -> begin
                               match (snd _1) f, (snd _3) args with
                                 Some m1, Some m2 -> Some (m1 @ m2)
                               | _, _ -> None
                             end
                           | _ -> None))
                         )
# 3096 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'arglo) in
    let _2 = (Parsing.peek_val __caml_parser_env 4 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'arguments) in
    Obj.repr(
# 1250 "src/formatparse.mly"
       ( ((fun loc args ->
                       Call((fst _1) args, Lval ((fst _2) args),
                            (fst _4) args, loc, locUnknown)), (* TODO: better eloc? *)

                        (fun i -> match i with
                          Call(lo, Lval f, args, loc, eloc) -> begin
                            match (snd _1) lo, (snd _2) f, (snd _4) args with
                              Some m1, Some m2, Some m3 ->
                                Some (m1 @ m2 @ m3)
                            | _, _, _ -> None
                          end
                        | _ -> None))
                     )
# 3117 "src/formatparse.ml"
               : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1267 "src/formatparse.mly"
                         ( let currentArg = _1 in
                           ((fun args ->
                             let res =
                               match getArg currentArg args with
                                 Flo x -> x
                               | a -> wrongArgType currentArg "lval option" a
                             in
                             res),

                            (fun lo -> Some [ Flo lo ]))
                         )
# 3134 "src/formatparse.ml"
               : 'arglo))
; (fun __caml_parser_env ->
    Obj.repr(
# 1280 "src/formatparse.mly"
                  ( ((fun args -> []),

                     (fun actuals -> match actuals with
                          [] -> Some []
                         | _ -> None))
                  )
# 3145 "src/formatparse.ml"
               : 'arguments))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'arguments_ne) in
    Obj.repr(
# 1287 "src/formatparse.mly"
                  ( _1 )
# 3152 "src/formatparse.ml"
               : 'arguments))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1291 "src/formatparse.mly"
                  ( ((fun args -> [ (fst _1) args ]),

                     (fun actuals -> match actuals with
                        [ h ] -> (snd _1) h
                       | _ -> None))
                  )
# 3164 "src/formatparse.ml"
               : 'arguments_ne))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1298 "src/formatparse.mly"
                  (  let currentArg = _1 in
                     ((fun args ->
                         match getArg currentArg args with
                           FE el -> el
                          | a -> wrongArgType currentArg "arguments" a),

                      (fun actuals -> Some [ FE actuals ]))
                  )
# 3178 "src/formatparse.ml"
               : 'arguments_ne))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'arguments_ne) in
    Obj.repr(
# 1308 "src/formatparse.mly"
                  ( ((fun args -> ((fst _1) args) :: ((fst _3) args)),

                     (fun actuals -> match actuals with
                         h :: rest -> begin
                           match (snd _1) h, (snd _3) rest with
                             Some m1, Some m2 -> Some (m1 @ m2)
                           | _, _ -> None
                         end
                       | _ -> None))
                  )
# 3195 "src/formatparse.ml"
               : 'arguments_ne))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)) in
    Obj.repr(
# 1324 "src/formatparse.mly"
                  ( (fun mkTemp loc args ->
                         mkStmt (If((fst _3) args,
                                    mkBlock [ _5 mkTemp loc args ],
                                    mkBlock [], loc, locUnknown))) (* TODO: better eloc *)
                  )
# 3207 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)) in
    Obj.repr(
# 1330 "src/formatparse.mly"
                  ( (fun mkTemp loc args ->
                         mkStmt (If((fst _3) args,
                                    mkBlock [ _5 mkTemp loc args ],
                                    mkBlock [ _7 mkTemp loc args], loc, locUnknown))) (* TODO: better eloc *)
                  )
# 3220 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'exp_opt) in
    Obj.repr(
# 1336 "src/formatparse.mly"
                  ( (fun mkTemp loc args ->
                         mkStmt (Return((fst _2) args, loc, locUnknown))) (* TODO: better eloc *)
                  )
# 3229 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)))
; (fun __caml_parser_env ->
    Obj.repr(
# 1340 "src/formatparse.mly"
                  ( (fun mkTemp loc args ->
                         mkStmt (Break loc))
                  )
# 3237 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)))
; (fun __caml_parser_env ->
    Obj.repr(
# 1344 "src/formatparse.mly"
                  ( (fun mkTemp loc args ->
                         mkStmt (Continue loc))
                  )
# 3245 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt list)) in
    Obj.repr(
# 1348 "src/formatparse.mly"
                  ( (fun mkTemp loc args ->
                         let stmts = _2 mkTemp loc args in
                         mkStmt (Block (mkBlock (stmts))))
                  )
# 3255 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)) in
    Obj.repr(
# 1353 "src/formatparse.mly"
                  ( (fun mkTemp loc args ->
                        let e = (fst _3) args in
                        let e =
                          if isPointerType(typeOf e) then
                            mkCast ~e:e ~newt:!upointType
                          else e
                        in
                        mkStmt
                          (Loop (mkBlock [ mkStmt
                                             (If(e,
                                                 mkBlock [],
                                                 mkBlock [ mkStmt
                                                             (Break loc) ],
                                                 loc, locUnknown)); (* TODO: better eloc *)
                                           _5 mkTemp loc args ],
                                 loc, locUnknown, None, None))) (* TODO: better eloc *)
                   )
# 3279 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'instr_list) in
    Obj.repr(
# 1370 "src/formatparse.mly"
                  ( (fun mkTemp loc args ->
                       mkStmt (Instr (_1 loc args)))
                  )
# 3288 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1373 "src/formatparse.mly"
                  ( let currentArg = _1 in
                    (fun mkTemp loc args ->
                       match getArg currentArg args with
                         Fs s -> s
                       | a -> wrongArgType currentArg "stmt" a) )
# 3299 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)))
; (fun __caml_parser_env ->
    Obj.repr(
# 1381 "src/formatparse.mly"
                 ( (fun mkTemp loc args -> []) )
# 3305 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt list)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1383 "src/formatparse.mly"
                 ( let currentArg = _1 in
                   (fun mkTemp loc args ->
                       match getArg currentArg args with
                       | FS sl -> sl
                       | a -> wrongArgType currentArg "stmts" a)
                 )
# 3317 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt list)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt)) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt list)) in
    Obj.repr(
# 1390 "src/formatparse.mly"
                 ( (fun mkTemp loc args ->
                      let this = _1 mkTemp loc args in
                      this :: (_2 mkTemp loc args))
                 )
# 3328 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt list)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : (Cil.attributes -> (string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option)) in
    let _2 = (Parsing.peek_val __caml_parser_env 4 : 'attributes) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'decl) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'maybe_init) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt list)) in
    Obj.repr(
# 1396 "src/formatparse.mly"
                ( (fun mkTemp loc args ->
                     let tal = (fst _2) args in
                     let ts  = (fst _1) tal args in
                     let (n, t, _) = (fst _3) ts args in
                     let init = _4 args in
                     (* Before we proceed we must create the variable *)
                     let v = mkTemp n t in
                     (* Now we parse the rest *)
                     let rest = _6 mkTemp loc ((n, Fv v) :: args) in
                     (* Now we add the initialization instruction to the
                        front *)
                     match init with
                       NoInit -> rest
                     | InitExp e ->
                         mkStmtOneInstr (Set((Var v, NoOffset), e, loc, locUnknown)) (* TODO: better eloc? *)
                         :: rest
                     | InitCall (f, args) ->
                         mkStmtOneInstr (Call(Some (Var v, NoOffset),
                                              Lval f, args, loc, locUnknown)) (* TODO: better eloc? *)
                         :: rest

                                                           )
                 )
# 3361 "src/formatparse.ml"
               : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt list)))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)) in
    Obj.repr(
# 1425 "src/formatparse.mly"
                 ( (fun loc args -> [ ((fst _1) loc args) ]) )
# 3368 "src/formatparse.ml"
               : 'instr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1426 "src/formatparse.mly"
                 ( let currentArg = _1 in
                   (fun loc args ->
                       match getArg currentArg args with
                       | FI il -> il
                       | a -> wrongArgType currentArg "instrs" a)
                 )
# 3380 "src/formatparse.ml"
               : 'instr_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option)) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'instr_list) in
    Obj.repr(
# 1433 "src/formatparse.mly"
                 ( (fun loc args ->
                      let this = (fst _1) loc args in
                      this :: (_2 loc args))
                 )
# 3391 "src/formatparse.ml"
               : 'instr_list))
; (fun __caml_parser_env ->
    Obj.repr(
# 1441 "src/formatparse.mly"
                                ( (fun args -> NoInit) )
# 3397 "src/formatparse.ml"
               : 'maybe_init))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option)) in
    Obj.repr(
# 1442 "src/formatparse.mly"
                                ( (fun args -> InitExp ((fst _2) args)) )
# 3404 "src/formatparse.ml"
               : 'maybe_init))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option)) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'arguments) in
    Obj.repr(
# 1444 "src/formatparse.mly"
                                ( (fun args ->
                                    InitCall((fst _2) args, (fst _4) args)) )
# 3413 "src/formatparse.ml"
               : 'maybe_init))
(* Entry initialize *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry expression *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry typename *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry offset *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry lval *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry instr *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry stmt *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry stmt_list *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let initialize (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : unit)
let expression (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 2 lexfun lexbuf : ((string * Cil.formatArg) list -> Cil.exp) * (Cil.exp -> Cil.formatArg list option))
let typename (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 3 lexfun lexbuf : ((string * Cil.formatArg) list -> Cil.typ) * (Cil.typ -> Cil.formatArg list option))
let offset (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 4 lexfun lexbuf : (Cil.typ -> (string * Cil.formatArg) list -> Cil.offset) * (Cil.offset -> Cil.formatArg list option))
let lval (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 5 lexfun lexbuf : ((string * Cil.formatArg) list -> Cil.lval) * (Cil.lval -> Cil.formatArg list option))
let instr (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 6 lexfun lexbuf : (Cil.location -> (string * Cil.formatArg) list -> Cil.instr) * (Cil.instr -> Cil.formatArg list option))
let stmt (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 7 lexfun lexbuf : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt))
let stmt_list (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 8 lexfun lexbuf : ((string -> Cil.typ -> Cil.varinfo) -> Cil.location -> (string * Cil.formatArg) list -> Cil.stmt list))
;;
